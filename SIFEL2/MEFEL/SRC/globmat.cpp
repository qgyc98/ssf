#include "globmat.h"
#include "mathem.h"
#include "global.h"
#include "elemhead.h"
#include "loadcase.h"
#include "dloadcase.h"
#include "dloadpd.h"
#include "node.h"
#include "element.h"
#include "intpoints.h"
#include "problem.h"
#include "probdesc.h"
#include "mechmat.h"
#include "mechtop.h"
#include "mechcrsec.h"
#include "mechbclc.h"
#include "lhsrhs.h"
//#include "mechcrsec.h"
#include "elemswitch.h"
#include "vecttens.h"
#include "globalg.h"
#include <errno.h>
#ifdef INC_OPENMP
 #include <omp.h>
#endif

#define DEBUGELEMFRC
//#include <chrono>
//#include <thread>

/**
  Function assembles stiffness %matrix.
  
  Parameters: 
  @param lcid - load case id
   
  @return The function does not return anything.

  Created by JK,
*/
void stiffness_matrix (long lcid)
{
  long i,j,nl,ndofe,ndofemn,ndofn,nmult,nid;
  ivector cn,cna;
  matrix lm,lmt;
  matrix alm,bd,db,dd;
  time_t bt,et;
  int err;
  
  bt = time (NULL);

  if (Smat==NULL)
    Smat = new gmatrix;

  Smat->setval (Mp->ssle);
  Smat->initiate (Gtm,Ndofm,Mp->tstorsm,Mespr,Out);
  
  //  the following condition is used only for problem type which
  //  deals with load balancing method
  //  the code stops here because it needs to compute number of matrix
  //  entries in the system matrix
  if (Mp->lbtype==1)
    abort ();
  
  
  //FILE *ma;
  //ma=fopen ("matice.txt","w");

  
  for (i=0;i<Mt->ne;i++){
    if (Gtm->leso[i]==1){
      //  only active elements are assembled
      //  this is used especially in problems with changing structures
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs without hanging nodes
      ndofe = Mt->give_ndofe (i);
      
      reallocm (RSTCKMAT(ndofe,ndofe,lm));
      //  computation of stiffness matrix of one element
      stiffmat (lcid,i,lm);

      err =check_math_errel(i);

      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtm->give_ndofe (i);
      reallocv (RSTCKIVEC(ndofemn,cn));
      Mt->give_code_numbers (i,cn.a);
      
      if (ndofe != ndofemn){
	if (Mb->give_num_mstress_comp(lcid)){
	  //  this case means homogenization with prescribed macro-stresses
	  long ii,jj,kk;
	  reallocm (RSTCKMAT(ndofe,ndofe,alm));
	  copym (lm,alm);
	  reallocm (RSTCKMAT(ndofemn,ndofemn,lm));	  
	  for (ii=0;ii<ndofe;ii++){
	    for (jj=0;jj<ndofe;jj++){
	      lm(ii, jj)=alm(ii, jj);
	    }
	  }
	  reallocm (RSTCKMAT(ndofe,ndofemn-ndofe,bd));
	  bdmatrix (lcid,i,bd); //bd_matrix
	  for (ii=0;ii<ndofe;ii++){
	    kk=ndofe;
	    for (jj=0;jj<ndofemn-ndofe;jj++){
	      lm(ii, kk)=bd(ii, jj);
	      kk++;
	    }
	  }
	  kk=ndofe;
	  //reallocm (RSTCKMAT(ndofemn-ndofe,ndofe,bd));//for non-symmetric stiffness matrix
	  //dbmatrix (lcid,i,bd); //db_matrix
	  for (ii=0;ii<ndofemn-ndofe;ii++){
	    for (jj=0;jj<ndofe;jj++){
	      lm(kk, jj)=bd(jj, ii);
	      //lm(kk, jj)=bd(ii, jj);//for non-symmetric stiffness matrix
	    }
	    kk++;
	  }
	  reallocm (RSTCKMAT(ndofemn-ndofe,ndofemn-ndofe,dd));
	  ddmatrix (lcid,i,dd); //dd_matrix
	  for (ii=0;ii<ndofemn-ndofe;ii++){
	    for (jj=0;jj<ndofemn-ndofe;jj++){
	      lm(ii+ndofe, jj+ndofe)=dd(ii, jj);
	    }
	  } 
	}
	else{
	  //  this case means hanging nodes
	  
	  //  the element contains hanging node
	  //  the stiffness matrix has to be transformed
	  reallocm (RSTCKMAT(ndofe,ndofemn,alm));
	  mxm (lm,*Mt->elements[i].tmat,alm);
	  reallocm (RSTCKMAT(ndofemn,ndofemn,lm));
	  mtxm (*Mt->elements[i].tmat,alm,lm);
	}
      }
      //  localization of matrix of one element to matrix of problem
      Smat->localize (lm,cn,i);
    }
  }
  
  //Smat->printmat (ma);
  //fclose (ma);
  
  /*
    fclose (ma);
    
    ma=fopen ("sit.txt","w");
    fprintf (ma,"%ld\n",Gtm->nn);
    for (i=0;i<Gtm->nn;i++){
    fprintf (ma,"%ld  %lf %lf %lf  %ld %ld %ld\n",i+1,Gtm->gnodes[i].x,Gtm->gnodes[i].y,Gtm->gnodes[i].z,Gtm->gnodes[i].cn[0],Gtm->gnodes[i].cn[1],Gtm->gnodes[i].cn[2]);
    }
    fprintf (ma,"\n\n%ld\n",Gtm->ne);
    for (i=0;i<Gtm->ne;i++){
    fprintf (ma,"%ld    %ld %ld %ld %ld\n",i+1,Gtm->gelements[i].nodes[0],Gtm->gelements[i].nodes[1],Gtm->gelements[i].nodes[2],Gtm->gelements[i].nodes[3]);
    //fprintf (ma,"%ld    %ld %ld %ld %ld %ld %ld %ld %ld\n",
    //i+1,Gtm->gelements[i].nodes[0],Gtm->gelements[i].nodes[1],Gtm->gelements[i].nodes[2],
    //Gtm->gelements[i].nodes[3],Gtm->gelements[i].nodes[4],Gtm->gelements[i].nodes[5],
    //Gtm->gelements[i].nodes[6],Gtm->gelements[i].nodes[7]);
    }
    fclose (ma);
  */
  
  
  
  /*
    DSS::SparseMatrixF sm((unsigned long)Ndofm,Smat->scr->a,(unsigned long*)Smat->scr->ci,(unsigned long*)Smat->scr->adr);
    FILE *out;
    out = fopen ("matice.sm","wb");
    sm.SaveMatrix(out);
  */
  
  if (Mp->tprob==layered_linear_statics){
    for (i=0;i<Mt->nln;i++){
      nl=Gtm->lgnodes[i].nl;
      ndofn=Gtm->lgnodes[i].ndofn;
      nmult=Gtm->lgnodes[i].nmult;
      //allocm (nmult,ndofn*2,lm);
      reallocm (RSTCKMAT(ndofn*2,nmult,lm));
      reallocm (RSTCKMAT(nmult,ndofn*2,lmt));
      //cn = new long [ndofn*2];
      reallocv (RSTCKIVEC(ndofn*2,cn));
      //cna = new long [nmult];
      reallocv (RSTCKIVEC(nmult,cna));
    
      for (j=1;j<nl;j++){
	constr_matrix (i,j,lm);
	
	nid=Gtm->lgnodes[i].nodes[j-1];
	Mt->give_node_code_numbers (nid,cn.a);
	nid=Gtm->lgnodes[i].nodes[j];
	Mt->give_node_code_numbers (nid,cn.a+ndofn);
	Mt->give_mult_code_numbers (i,j,cna.a);
	
	tranm (lm,lmt);
	
	Smat->glocalize (lmt,cna,cn);
	Smat->glocalize (lm,cn,cna);
	
	
      }
    }
  }
  
  Smat->prepmat (0.0,Mespr);
  
  //Smat->printdiag(Out);
  //Smat->printmat(Out);
  
  et = time (NULL);
//  fprintf (stdout,"\n stiffness matrix assembling time    %ld",et-bt);
  fflush(stdout);
  
}



/**
  Function assembles mass %matrix.
   
  Parameters:
  @param lcid - load case id
   
  @return The function does not return anything.

  Created by JK,
*/
void mass_matrix (long lcid)
{
  long i,ndofe,ndofemn;
  ivector cn;
  matrix lm;
  matrix alm;
  
  if (Mmat==NULL)  Mmat = new gmatrix;
  //Mmat->ts=Mp->tstormm;
  Mmat->setval (Mp->ssle);
  Mmat->initiate (Gtm,Ndofm,Mp->tstormm,Mespr,Out);
  //Mmat->setval (Mp->ssle.tlinsol,Mp->ssle.prec.pt,Mp->ssle.ni,Mp->ssle.err);
  
  
  for (i=0;i<Mt->ne;i++){
    if (Gtm->leso[i]==1){
      //  number of DOFs on the i-th element
      ndofe = Mt->give_ndofe (i);
      //  allocation of element mass matrix
      reallocm (RSTCKMAT(ndofe,ndofe,lm));
      //  computation of mass matrix of one element
      massmat (lcid,i,lm);
      


      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtm->give_ndofe (i);
      reallocv (RSTCKIVEC(ndofemn,cn));
      Mt->give_code_numbers (i,cn.a);
      
      if (ndofe != ndofemn){
	//  the element contains hanging node
	//  the mass matrix has to be transformed
	reallocm (RSTCKMAT(ndofe,ndofemn,alm));
	mxm (lm,*Mt->elements[i].tmat,alm);
	reallocm (RSTCKMAT(ndofemn,ndofemn,lm));
	mtxm (*Mt->elements[i].tmat,alm,lm);
      }
      
      //  localization of matrix of element to matrix of problem
      Mmat->localize (lm,cn,i);
    }
  }
  
  /*
  for (i=0;i<Mt->nn;i++){
    cr = Mt->nodes[i].crst;
    if (cr==nocrosssection){
      continue;
    }
    else{
      ndofn = Mt->give_ndofn (i);
      for (j=0;j<ndofn;j++){
	k = Mt->give_dof (i,j);
	if (k>0){
	  idcs = Mt->nodes[i].idcs;
	  m=Mc->give_weight (cr,idcs);
	  Mmat->add_entry (m,k-1,k-1);
	}
      }
    }
  }
  */

  Mmat->prepmat (0.0,Mespr);
}



/**
  Function assembles initial stiffness %matrix.

  It is also called geometric stiffness %matrix
  (in R.W. Clough and J. Penzien: Dynamics of structures)

  Parameters:   
  @param lcid - load case id
   
  @return The function does not return anything.

  Created by JK,
*/
void initial_stiffness_matrix (long lcid)
{
  if (Ismat==NULL)  Ismat = new gmatrix;
  //Ismat->ts=Mp->tstorsm;
  Ismat->setval (Mp->ssle);
  Ismat->initiate (Gtm,Ndofm,Mp->tstorsm,Mespr,Out);
  //Ismat->setval (Mp->ssle.tlinsol,Mp->ssle.prec.pt,Mp->ssle.ni,Mp->ssle.err);
  
  
  long i,ndofe,ndofemn;
  ivector cn;
  matrix lm;
  matrix alm;
  
  for (i=0;i<Mt->ne;i++){
    if (Gtm->leso[i]==1){

      ndofe = Mt->give_ndofe (i);
      
      reallocm (RSTCKMAT(ndofe,ndofe,lm));
      
      //  computation of initial stiffness matrix of one element
      initstiffmat (lcid,i,lm);
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtm->give_ndofe (i);
      reallocv (RSTCKIVEC(ndofemn,cn));
      //cn = new long [ndofe];
      Mt->give_code_numbers (i,cn.a);
      
      if (ndofe != ndofemn){
	//  the element contains hanging node
	//  the initial stiffness matrix has to be transformed
	reallocm (RSTCKMAT(ndofe,ndofemn,alm));
	mxm (lm,*Mt->elements[i].tmat,alm);
	reallocm (RSTCKMAT(ndofemn,ndofemn,lm));
	mtxm (*Mt->elements[i].tmat,alm,lm);
      }
      
      //  localization of matrix of one element to matrix of problem
      Ismat->localize (lm,cn,i);
    }
  }
  
  Ismat->prepmat (0.0,Mespr);
}



/**
  The function assembles damping %matrix.
   
  @return The function does not return anything.

  Created by JK, 10.8.2005
*/
void damping_matrix (long lcid)
{
  long i,ndofe,ndofemn;
  ivector cn;
  matrix lm,alm;

  if (Dmat==NULL)  
    Dmat = new gmatrix;
  
  if (Mp->damp==elemdamp){
    //  damping is defined by material model
    Dmat->initiate (Gtm,Ndofm,Mp->tstordm,Mespr,Out);
  }else{
    //  damping matrix is a multiple of the mass or stiffness matrix
    Dmat->initiate (Gtm,Ndofm,Mp->tstorsm,Mespr,Out);
  }
  Dmat->setval (Mp->ssle);
  
  switch (Mp->damp){
  case nodamp:{
    break;
  }
  case massdamp:{
    Dmat->addgm (Mp->dmass,*Mmat);
    break;
  }
  case stiffdamp:{
    Dmat->addgm (Mp->dstiff,*Smat);
    break;
  }
  case rayleighdamp:{
    Dmat->addgm (Mp->dmass,*Mmat);
    Dmat->addgm (Mp->dstiff,*Smat);
    break;
  }
  case elemdamp:{
    //  damping matrix is assembled element by element
    
    for (i=0;i<Mt->ne;i++){
      if (Gtm->leso[i]==1){
	//  only elements which are switched on are taken into account
	
	//  number of DOFs on the i-th element
	ndofe = Mt->give_ndofe (i);
	//  allocation of element mass matrix
	reallocm (RSTCKMAT(ndofe,ndofe,lm));
	//  computation of damping matrix of one element
	dampmat (lcid,i,lm);
	
	//  the number of DOFs on element
	//  this number is equal to the number of DOFs with master nodes generated by hanging nodes
	ndofemn = Gtm->give_ndofe (i);
	reallocv (RSTCKIVEC(ndofemn,cn));
	Mt->give_code_numbers (i,cn.a);
	
	if (ndofe != ndofemn){
	  //  the element contains hanging node
	  //  the damping matrix has to be transformed
	  reallocm (RSTCKMAT(ndofe,ndofemn,alm));
	  mxm (lm,*Mt->elements[i].tmat,alm);
	  reallocm (RSTCKMAT(ndofemn,ndofemn,lm));
	  mtxm (*Mt->elements[i].tmat,alm,lm);
	}
	
	//  localization of matrix of element to matrix of problem
	Dmat->localize (lm,cn,i);
      }
    }
    
    break;
  }
  default:{
    print_err("unknown type of damping is required",__FILE__,__LINE__,__func__);
  }
  }
  
  Dmat->prepmat (0.0,Mespr);
}



/**
  The function computes %vector of internal forces.
   
  @param lcid - load case id
  @param intfor - %vetcor of internal forces (output)
   
  @return The function returns %vector of internal forces
  in the parameter intfor.

  Created by JK, 28.7.2001
*/
void internal_forces (long lcid,double *intfor)
{
  if (Mp->matmodel==local){
    loc_internal_forces (lcid,intfor);
  }
  if (Mp->matmodel==nonlocal){
    nonloc_internal_forces (lcid,intfor);
  }
  
  //  contribution to internal forces by Lagrange multipliers
  //  it is used in problems with floating subdomains solved by the FETI method
  //  JK, 22.6.2006
  if (Mp->tprob == lin_floating_subdomain || Mp->tprob == nonlin_floating_subdomain){
    //lagrmultcontr_intforces (lcid,intfor);
  }

  
  //  indicator of strain computation
  //  it means, strains at integration points have been computed
  Mp->strainstate=1;
  //  indicator of stress computation
  //  it means, stresses at integration points have been computed
  Mp->stressstate=1;
  //  indicator of computation of other array
  //  it means, stresses at integration points have been computed
  Mp->otherstate=1;
}



/**
  The function computes %vector of internal forces,
  local material models are used.

  @param lcid - load case id
  @param intfor - %vector of internal forces (output)
   
  @return The function returns %vector of internal forces computed localy
  in the parameter intfor.

  Created by JK, TKo,  28.7.2001
*/
void loc_internal_forces (long lcid,double *intfor)
{
  long i,j,ndofe,ndofemn, ncomp=0L, eid;
  ivector cn;
  int err;
  vector ifor, aifor;
  
  //  function computes strains at integration points
  if (Mp->strcomp)
    compute_ipstrains (lcid);

#ifdef DEBUGELEMFRC
  if (Elemfrc == NULL){
    Elemfrc = new vector[Mt->ne];
    for (i=0; i<Mt->ne; i++){
      ndofe = Mt->give_ndofe(i);
      reallocv(ndofe, Elemfrc[i]);
    }
  }
#endif

  //  number of elements
  long ne=Mt->ne;
  ivector seq(ne);
  long g = 0;
#ifdef INC_OPENMP  
  double druntime = omp_get_wtime();
#else
  double druntime = clock();
#endif  
  //  cleaning of the array intfor 
  nullv (intfor,Ndofm);  
#ifdef INC_OPENMP  
  double mstresscomp[6] = {};  // reduction array for integrated macrostress contributions from elements
#pragma omp parallel \
        num_threads(Numth),\
  private(i, j, ndofe, ndofemn, eid, cn, err, ifor, aifor),    \
        firstprivate(ncomp)
  {    
 #ifdef __linux__
  #pragma omp for reduction(+:mstresscomp[:6])
 #else
  #pragma omp for
 #endif
#endif
    for (i=0;i<ne;i++){
      if (Gtm->leso[i]==1){
#ifdef INC_OPENMP
        //eid = Gtm->ompelord[i];
        eid = i;
#else
        eid = i;
#endif
        //  the number of DOFs on element
        //  this number is equal to the number of DOFs without hanging nodes
        ndofe=Mt->give_ndofe (eid);
        reallocv (RSTCKVEC(ndofe,ifor));
        
        elem_internal_forces (eid,lcid,ifor);
	
        err = check_math_errel(eid);
	
        if (err) abort();
	
        //  the number of DOFs on element
        //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
        ndofemn = Gtm->give_ndofe (eid);
        reallocv (RSTCKIVEC(ndofemn,cn));

        Mt->give_code_numbers (eid,cn.a);

        if (ndofe != ndofemn){
          if (Mb->give_num_mstress_comp(lcid)){
            //  this case means homogenization with some prescribed macro-stress components
            if (ncomp == 0L)
              ncomp = ndofemn-ndofe;

            // localize contribution from standard element stresses due 
            // to macro-strains and fluctuations 
            // (macro-strains are added in compute_ipstrains function)
            locglob (intfor,ifor.a,cn.a,ndofe);

            // contribution to macro-stresses due to macro-strains and fluctuations
            // (macro-strains are added in compute_ipstrains function),
            // \mathbf{f} = \int_{\Omega} \mathbf{\sigma} \mathrm{dV} (it is not internal force)
            reallocv (RSTCKVEC(ncomp, ifor));
            elem_volintegration_quant(eid, locstress, lcid, ifor);
            long *mstress_cn = Mb->give_mstress_cn(lcid);
            for (j=0; j<ncomp; j++){
              if (mstress_cn[j]){
#ifdef INC_OPENMP
                // OS dependent multithread code
              #ifdef __linux__
                mstresscomp[j] += ifor[j]; // uses reduction clause for mstresscomp update in the #pragma for loop
              #else           
               #pragma omp critical 
                // Windows compiler does not support the latest array reduction clause in the for loop,
                // thus the critical section construct must be used
                {
                  mstresscomp[j] += ifor[j];
                }
              #endif // end of OS dependent multithread code
#else
                // sequential code
                intfor[mstress_cn[j]-1] += ifor[j];
#endif
              }
            }
          }  
          else{
            //  this case means hanging nodes
            //  the element contains hanging node
            //  the stiffness matrix has to be transformed
            reallocv (RSTCKVEC(ndofemn,aifor));
            mtxv (*Mt->elements[eid].tmat,ifor,aifor);
            #if defined(INC_OPENMP) && defined(_WIN32)
             #pragma omp critical
              // Windows compiler do not support latest OpenMP versions with atomic construct,
              // thus the critical section must be used
              {
                locglob(intfor, aifor.a, cn.a, ndofemn);
              }
            #else // in other cases atomic update of intfor is provided at the level of locglob procedure
              locglob (intfor,aifor.a,cn.a,ndofemn);
            #endif
          }
        }
	else{
          //  the element does not contain hanging node nor homogenization
        #if defined(INC_OPENMP) && defined(_WIN32)
         #pragma omp critical  
          // Windows compiler do not support latest OpenMP versions with atomic construct,
          // thus the critical section must be used. On Linux systems, the atomic update is provided in locglob.
        #endif  
          {
            locglob(intfor, ifor.a, cn.a, ndofe);
          }
         // the following code is for debugging of possible data races
         #if defined(INC_OPENMP)
          #pragma omp critical  
         #endif
          {
            g++;
            seq(i) = g;
          }
        }
      } // end of leso test
#ifdef DEBUGELEMFRC
      copyv(ifor, Elemfrc[i]);
#endif
    }// end element loop
#ifdef INC_OPENMP
  }// end of #pragma block
  ncomp = Mb->give_num_mstress_comp(lcid);
  if (ncomp){ // homogenization with macrostress approach was detected
    long *mstress_cn = Mb->give_mstress_cn(lcid);
    for (j=0; j<ncomp; j++){
      if (mstress_cn[j]){
        intfor[mstress_cn[j]-1] += mstresscomp[j];
      }
    }
  }
  druntime = omp_get_wtime() - druntime;
  Omp_wtime += druntime;
#else
  druntime = (clock() - druntime)/(double)CLOCKS_PER_SEC;
  Omp_wtime += druntime;  
#endif

#ifdef INC_OPENMP
  //fprintf(Out, "Element sequence for istep=%ld, jstep=%ld:\n", Mp->istep, Mp->jstep);
  //printv(seq, Out);
#endif
  
#ifdef DEBUGELEMFRC
  //fprintf(Out, "\nistep=%ld, jstep=%ld\n", Mp->istep, Mp->jstep);
  nullv (intfor,Ndofm);  

  for(i=0; i<Mt->ne; i++){
    ndofe=Mt->give_ndofe(i);
    ndofemn = Gtm->give_ndofe (i);
    reallocv (RSTCKIVEC(ndofemn,cn));
    Mt->give_code_numbers (i,cn.a);
    locglob (intfor,Elemfrc[i].a, cn.a, ndofe);
    
    //fprintf(Out, "eid=%4ld\n", i+1);
    //for(j=0; j<Elemfrc[i].n; j++)
    //fprintf(Out, " % .15le", Elemfrc[i][j]);
    //fprintf(Out, "\n");
  }
  //fprintf(Out, "\nElement order: istep=%ld, jstep=%ld\n", Mp->istep, Mp->jstep);
  //for(i=0; i<Mt->ne; i++)
  //fprintf(Out, "%5ld\n", h(i));
  
  //fprintf(Out, "\nInternal force vector: istep=%ld, jstep=%ld\n", Mp->istep, Mp->jstep);
  //for(i=0; i<Ndofm; i++){
  //fprintf(Out, " % .15le\n", intfor[i]);
  //}
  //fflush(Out);
#endif
}



/**
  The function computes %vector of internal forces,
  nonlocal material models are used.

  @param lcid - load case id
  @param intfor - %vector of internal forces (output)

  @return The function returns %vector of internal forces computed nonlocaly
  in the parameter intfor.

  Created by JK,TKo, 28.7.2001
*/
void nonloc_internal_forces (long lcid,double *intfor)
{
  long i,ne,ndofe,ndofemn;
  ivector cn;
  vector ifor;
  vector aifor;
  matrix d;
  vector r;

  //  function computes strains at integration points
  if (Mp->strcomp)
    compute_ipstrains (lcid);

  ne=Mt->ne;
  nullv (intfor,Ndofm);
  Mp->nonlocphase=1;

#ifdef INC_OPENMP  
#pragma omp parallel num_threads(Numth)
{    
#pragma omp for private(i)
#endif
  for (i = 0; i < ne; i++)
  {
    if (Gtm->leso[i]==1)
     elem_local_values (i, lcid);
  }
  
#ifdef INC_OPENMP  
#pragma omp for private(i)
#endif
  for (i = 0; i < Mm->tnip; i++)
    Mm->nonlocaverage(i);
  Mp->nonlocphase=2;
  
#ifdef INC_OPENMP  
#pragma omp for private(i, ndofe, ndofemn, cn, ifor, aifor, d, r)
#endif
  for (i = 0; i < ne; i++)
  {
    if (Gtm->leso[i]==1)
    {
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs without hanging nodes
      ndofe=Mt->give_ndofe (i);
      reallocv (RSTCKVEC(ndofe,ifor));

      // if (Mt->elements[i].te == hexintface){
      //   reallocm (RSTCKMAT(ndofe, ndofe, d));
      //   reallocv (RSTCKVEC(ndofe, r));
      //   stiffmat(lcid, i, d);
      //   eldispl(lcid, i, r.a);
      //   mxv(d, r, ifor);
      // }
      // else
      elem_nonloc_internal_forces(i, lcid, ifor);

      check_math_errel(i);

      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtm->give_ndofe (i);
      reallocv (RSTCKIVEC(ndofemn,cn));

      Mt->give_code_numbers (i,cn.a);
      if (ndofe != ndofemn){
	//  the element contains hanging node
	//  the stiffness matrix has to be transformed
	reallocv (RSTCKVEC(ndofemn,aifor));
	mtxv (*Mt->elements[i].tmat,ifor,aifor);
	locglob (intfor,aifor.a,cn.a,ndofemn);
      }else{
	//  the element does not contain hanging node
	locglob (intfor,ifor.a,cn.a,ndofe);
      }
    }
  }
#ifdef INC_OPENMP
}
#endif
}



/**
  The function computes %vector of increments of internal forces.
   
  @param lcid - load case id
  @param intfor - %vector of increments of internal forces (output)
   
  @return The function returns %vector of increments of internal forces 
  in the parameter intfor.

  Created by JK, TKo, 29.4.2008
*/
void incr_internal_forces (long lcid,double *intfor)
{
  long i,ne,ndofe,ndofemn;
  ivector cn;
  vector ifor;
  vector aifor;
  
  //  function computes strains at integration points
  compute_ipstrains (lcid);
    
  //  number of elements
  ne=Mt->ne;
  
  //  cleaning of the array intfor
  nullv (intfor,Ndofm);
  
  for (i=0;i<ne;i++){
    if (Gtm->leso[i]==1){
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs without hanging nodes
      ndofe=Mt->give_ndofe (i);
      reallocv (RSTCKVEC(ndofe,ifor));
      
      elem_incr_internal_forces (i,lcid,ifor);

      check_math_errel(i);
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtm->give_ndofe (i);
      reallocv (RSTCKIVEC(ndofemn,cn));
      
      Mt->give_code_numbers (i,cn.a);

      if (ndofe != ndofemn){
	//  the element contains hanging node
	//  the stiffness matrix has to be transformed
	reallocv (RSTCKVEC(ndofemn,aifor));
	mtxv (*Mt->elements[i].tmat,ifor,aifor);
	locglob (intfor,aifor.a,cn.a,ndofemn);
      }else{
	//  the element does not contain hanging node
	locglob (intfor,ifor.a,cn.a,ndofe);
      }
    }
  }
}



/**
  Function adds contributions to internal forces caused by
  Lagrange multipliers. Function is used in problems with floating subdomains
  solved by the FETI method.
   
  @param lcid - load case id
  @param intfor - array of internal forces (input/output)
   
  @return The function adds contributions to the parameter intfor.

  Created by JK, 22.6.2006
*/
/*
void lagrmultcontr_intforces (long lcid,double *intfor)
{
  long i;
  double *av,*av1,*av2,*cv;
  
  av = new double [Ndofm];
  av1 = new double [Ndofm];
  av2 = new double [Ndofm];
  cv = new double [Fsd->nlm];
  
  //  E^T lamba
  nullv (av,Ndofm);
  nullv (av1,Ndofm);
  nullv (av2,Ndofm);
  //Gtm->flsub.coarse_local (Fsd->tw,av);
  Gtm->flsub.coarse_local (Fsd->muo,av1);
  Gtm->flsub.coarse_local (Fsd->ddmu,av2);
  
  for (i=0;i<Ndofm;i++){
    av[i]=av1[i]+av2[i];
  }
*/
  //Gtm->flsub.local_coarse (cv,Lsrs->lhs);
  
  /*
  long i;
  for (i=0;i<Ndofm;i++){
    fprintf (Out,"\n lagr mult %le",av[i]);
  }
  for (i=0;i<Fsd->nlm;i++){
    fprintf (Out,"\n coarse vector %le",cv[i]);
    

    if (cv[i]>10.0){
      if (av[i]<0.0){
	av[i]=-10.0;
	Fsd->tw[i]=-10.0;
      }
      if (av[i]>0.0){
	av[i]=10.0;
	Fsd->tw[i]=10.0;
      }
      Fsd->compli[i]=2.0;
    }
    
  }
  */
/*
  addv (intfor,av,Ndofm);
  
  delete [] av;
  delete [] cv;
}
*/


/**
   The function computes %vector of nodal forces
   caused by eigenstrains. Eigenstrains may contain 
   either eigenstrains or temperature strains.
   
   @param lcid - load case id
   @param nodfor - %vector of nodal forces (output)
   @param time - actual time
   
   @return The fucntion returns nodal forces in the parameter nodfor.
   
   Created by JK, 28.7.2001
*/
void nodal_eigstrain_forces (long lcid,double *nodfor,double time)
{
  long i,ne,ndofe,ndofemn;
  ivector cn;
  vector nfor;
  vector anfor;
  
  //  array nodfor must not be cleaned
  //  it contains contributions from previous calculations
  //  this function should only contribute to this array
  
  if (Mp->eigstrains==1 || Mp->eigstrains==2) 
    Mb->eigstrain_computation (time);
  
  if (Mp->eigstrains==4 || Mp->eigstrains==5) 
  {
    Mb->eigstrain_computation (time);
    Mp->eigstrcomp = 0; 
  }

  //  the number of elements
  ne=Mt->ne;
  
  for (i=0;i<ne;i++){
    if (Gtm->leso[i]==1){
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs without hanging nodes
      ndofe=Mt->give_ndofe (i);
      reallocv (RSTCKVEC(ndofe,nfor));

      //  computes contribution from one element
      elem_eigstrain_forces (lcid,i,nfor);

      // change sign of contribution nfor from element because loacalization 
      // procedure adds it to the global vector and the resulting global vector is 
      // added to the global right hand side vector
      // K_e r_e = f_e - \int\limits_\Omega_e B^T D_e \eps_0 dV
      // K_e r_e = f_e - \int\limits_\Omega_e B^T \sigma_0 dV
      // K_e r_e = f_e - nfor
      chsgnv(nfor);

      check_math_errel(i);

      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtm->give_ndofe (i);
      reallocv (RSTCKIVEC(ndofemn,cn));
      
      Mt->give_code_numbers (i,cn.a);

      if (ndofe != ndofemn){
	//  the element contains hanging node
	//  the vector has to be transformed
	reallocv (RSTCKVEC(ndofemn,anfor));
	mtxv (*Mt->elements[i].tmat,nfor,anfor);
	locglob (nodfor,anfor.a,cn.a,ndofemn);
      }else{
	//  the element does not contain hanging node
	locglob (nodfor,nfor.a,cn.a,ndofe);
      }
    }
  }
}



/**
   The function computes %vector of nodal forces
   caused by prescribed eigenstresses.
   
   @param lcid - load case id
   @param nodfor - %vector of nodal forces (output)
   @param time - actual time
   
   @return The fucntion returns nodal forces in the parameter nodfor.
   
   Created by JK, 28.7.2001
*/
void nodal_eigstress_forces (long lcid,double *nodfor,double time)
{
  long i,ne,ndofe,ndofemn;
  ivector cn;
  vector nfor;
  vector anfor;

  
  if (Mp->eigstrains==4 || Mp->eigstrains==5) 
  {
    Mb->eigstrain_computation (time);
    Mp->eigstrcomp = 0; 
  }
  else{
    print_err("eigenstrains were defined in the problem (Mp->eigstrains=%d),\n"
              "this function is not intended for this case and sould not be called at all.",
              __FILE__, __LINE__, __func__, int(Mp->eigstrains));
    abort();
  }
    

  nullv(nodfor, Ndofm);

  //  the number of elements
  ne=Mt->ne;
  
  for (i=0;i<ne;i++){
    if (Gtm->leso[i]==1){
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs without hanging nodes
      ndofe=Mt->give_ndofe (i);
      reallocv (RSTCKVEC(ndofe,nfor));

      //  computes contribution from one element
      elem_eigstrain_forces (lcid,i,nfor);

      // change sign of contribution nfor from element because loacalization 
      // procedure adds it to the global vector and the resulting global vector is 
      // added to the global right hand side vector
      // K_e r_e = f_e - \int\limits_\Omega_e B^T D_e \eps_0 dV
      // K_e r_e = f_e - \int\limits_\Omega_e B^T \sigma_0 dV
      // K_e r_e = f_e - nfor
      chsgnv(nfor);

      check_math_errel(i);

      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtm->give_ndofe (i);
      reallocv (RSTCKIVEC(ndofemn,cn));
      
      Mt->give_code_numbers (i,cn.a);

      if (ndofe != ndofemn){
	//  the element contains hanging node
	//  the vector has to be transformed
	reallocv (RSTCKVEC(ndofemn,anfor));
	mtxv (*Mt->elements[i].tmat,nfor,anfor);
	locglob (nodfor,anfor.a,cn.a,ndofemn);
      }else{
	//  the element does not contain hanging node
	locglob (nodfor,nfor.a,cn.a,ndofe);
      }
    }
  }
}



/**
   The function computes %vector of nodal forces
   caused by pore pressures. The function is employed only for
   coupled problems where the pore pressures are defined in TRFEL 
   out of the MEFEL control.
   
   
   @param lcid - load case id
   @param nodfor - %vector of nodal forces (output)
   @param time - actual time
   
   @return The fucntion returns nodal forces in the parameter nodfor.
   
   Created by JK, 28.7.2001
*/
void nodal_pore_press_forces (long lcid,double *nodfor,double time)
{
  long i,ne,ndofe,ndofemn, besc;
  ivector cn;
  vector nfor;
  vector anfor;
  double u;        // pore pressure
  vector sigt(6);
  //matrix sigt(3,3);
  vector sig;
  
  //  array nodfor must not be cleaned
  //  it contains contributions from previous calculations
  //  this function should only contribute to this array
  
  for(i=0; i<Mm->tnip; i++)
  {
    u = Mm->givenonmechq(eff_pore_pressure, i);
    reallocv(RSTCKVEC(Mm->ip[i].ncompstr, sig));
    sigt[0] = sigt[1] = sigt[2] = u;
    give_red_vector(sigt,sig,Mm->ip[i].ssst);
    Mm->storeeigstress(i, sig);
  }

  // eigenstresses have been already defined above and they must not be rewritten
  besc = Mp->eigstrcomp; // backup of eigenstress compuation flag
  Mp->eigstrcomp = 0; 

  //  the number of elements
  ne=Mt->ne;
  
  for (i=0;i<ne;i++){
    if (Gtm->leso[i]==1){
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs without hanging nodes
      ndofe=Mt->give_ndofe (i);
      reallocv (RSTCKVEC(ndofe,nfor));
      
      //  computes contribution from one element
      elem_eigstrain_forces (lcid,i,nfor);

      // change sign of contribution nfor from element because loacalization 
      // procedure adds it to the global vector and the resulting global vector is 
      // added to the global right hand side vector
      // K_e r_e = f_e - \int\limits_\Omega_e B^T u where u  is the vector of pore pressures
      // K_e r_e = f_e - nfor
      chsgnv(nfor);

      check_math_errel(i);

      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtm->give_ndofe (i);
      reallocv (RSTCKIVEC(ndofemn,cn));
      
      Mt->give_code_numbers (i,cn.a);

      if (ndofe != ndofemn){
	//  the element contains hanging node
	//  the vector has to be transformed
	reallocv (RSTCKVEC(ndofemn,anfor));
	mtxv (*Mt->elements[i].tmat,nfor,anfor);
	locglob (nodfor,anfor.a,cn.a,ndofemn);
      }else{
	//  the element does not contain hanging node
	locglob (nodfor,nfor.a,cn.a,ndofe);
      }
    }
  }

  // restore original status of eigenstress computation flag
  Mp->eigstrcomp = besc;
  if (Mp->eigstrains > 3){
    // pore pressure force computation uses eigenstress arrays on integration point,
    // therefore recalcualtion of eigenstresses is needed
    Mb->eigstrain_computation(time);
  }
}



/**
  The function extracts displacements on one element.
   
  @param lcid[in] - number of load case
  @param eid[in] - element id
  @param r[out] - allocated array for displacement
   
  @return The function returns nodal displacements at the given element in the array r.

  Created by JK, 9.7.2001
*/
void eldispl (long lcid,long eid,double *r)
{
  long i,j,ii,ndofe,ndofemn,nne,ndofn,acn;
  ivector cn,nod,ncn;
  vector rr;
  
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs without hanging nodes
  ndofe = Mt->give_ndofe (eid);
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
  ndofemn = Gtm->give_ndofe (eid);
  
  if (ndofe == ndofemn){
    //  there are no hanging nodes on element
    reallocv (RSTCKIVEC(ndofe,cn));
    reallocv (RSTCKVEC(ndofe,rr));
  }
  else{
    //  there are hanging nodes on element
    reallocv (RSTCKIVEC(ndofemn,cn));
    reallocv (RSTCKVEC(ndofemn,rr));
    ndofe=ndofemn;
  }
  //  code numbers on element
  Mt->give_code_numbers (eid,cn.a);
  
  
  switch (Mp->tprob){
  case forced_dynamics:
  case mech_timedependent_prob:{
    //  lcid must be equal to zero
    for (i=0;i<ndofe;i++){
      ii=cn[i];
      if (ii<0)   rr[i]=Mb->dlc[lcid].get_pd(Mp->time, ii);
      if (ii==0)  rr[i]=0.0;
      if (ii>0)   rr[i]=Lsrs->lhs[lcid*Ndofm+ii-1];
    }
    break;
  }

  case mat_nonlinear_statics:{
    for (i=0;i<ndofe;i++){
      ii=cn[i];
      if (ii<0)
      {   
        rr[i] = 0.0;
        if (Mb->lc[lcid].npd)
          rr[i] += Mb->lc[lcid].pd[0-ii-1] * Mp->lambda;
        if (Mb->lc[lcid+1].npd)
          rr[i]+= Mb->lc[lcid+1].pd[0-ii-1];
      }
      if (ii==0)  rr[i]=0.0;
      if (ii>0)   rr[i]=Lsrs->lhs[lcid*Ndofm+ii-1];
    }
    break;
  }
    
  case growing_mech_structure:{
    //  lcid must be equal to zero
    
    //  the number of nodes on element
    //  if there are hanging nodes, the master nodes are included
    nne = Gtm->give_nne(eid);
    
    reallocv (RSTCKIVEC(nne,nod));
    //  nodes on element
    Gtm->give_nodes (eid,nod);
    
    acn=0;
    //  loop over the number of nodes on element
    for (i=0;i<nne;i++){
      
      //  the number of DOFs on node
      ndofn = Gtm->give_ndofn (nod[i]);
      if (ndofn < 0){
        print_err("invalid master node defined on element %ld, ndofn=%ld < 0 of %ld-th master node with id %ld.",
                  __FILE__, __LINE__, __func__, eid+1, ndofn, i+1, nod[i]+1);
        abort();
      }
      
      reallocv (RSTCKIVEC(ndofn,ncn));
      //  code numbers in node
      Gtm->give_node_code_numbers (nod[i],ncn.a);
      
      //  loop over the number of DOFs in node
      for (j=0;j<ndofn;j++){
	ii=ncn[j];
	if (ii<0)   rr[acn+j]=Mb->dlc[lcid].get_pd(Mp->time, ii);
	if (ii==0)  rr[acn+j]=0.0;
	if (ii>0)   rr[acn+j]=Lsrs->lhs[lcid*Ndofm+ii-1];
	
        if (Mt->nodedispl[nod[i]] && (ii < 1)) 
	  // add initial displacements from previous free state of dof 
	  // in the case that the dof has got support or prescribed displacement actually
          rr[acn+j] += Mt->nodedispl[nod[i]][j];
      }//  end of the loop over the number of DOFs in node
      acn += ndofn;
    }//  end of the loop over the number of nodes on element
    
    break;
  }
    
  default:{
    for (i=0;i<ndofe;i++){
      ii=cn[i];
      if (ii<0)   rr[i]=Mb->lc[lcid].pd[0-ii-1];
      if (ii==0)  rr[i]=0.0;
      if (ii>0)   rr[i]=Lsrs->lhs[lcid*Ndofm+ii-1];
    }
  }
  }//  end of the switch (Mp->tprob)
  
  //  the variables ndofe and ndofemn have to be obtained again
  //  because they are possibly rewritten
  //
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs without hanging nodes
  ndofe = Mt->give_ndofe (eid);
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
  ndofemn = Gtm->give_ndofe (eid);
  
  if (ndofe != ndofemn){
    if (Mb->give_num_mstress_comp(lcid)){
      //  this case means homogenization based on the prescribed macro-stress component approach
      //  the vector rr contains more components than the vector r
      //  only the "classical" components are copied
      copyv (rr.a,r,ndofe);
    }   
    else{
      //  this case means hanging nodes
      
      //  there are hanging nodes on element
      mxv (Mt->elements[eid].tmat->a,rr.a,r,ndofe,ndofemn);
    }
  }
  else{
    //  there are no hanging nodes on element
    copyv (rr,r);
  }
  
  if (Mp->tprob == growing_mech_structure){
    //  subtraction of initial displacements
    Mt->elements[eid].subtrinitdispl (r, ndofe);
  }
  
  
  destrv (rr);
  destrv (cn);
}



/**
  The function extracts prescribed displacements on one element.
   
  @param lcid - number of load case
  @param eid - element id
  @param r - array of prescribed displacements, it is output parameter
  
  @return The function returns extracted prescribed displacements in the array r.

  Created by JK, 9.7.2001
*/
 void elprdispl (long lcid,long eid,double *r)
{
  long i,ii,ndofe,ndofemn;
  ivector cn,nod,ncn;
  vector rr;
  
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs without hanging nodes
  ndofe = Mt->give_ndofe (eid);
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
  ndofemn = Gtm->give_ndofe (eid);
  
  if (ndofe != ndofemn){
    //  there are hanging nodes on element
    reallocv (RSTCKIVEC(ndofemn,cn));
    reallocv (RSTCKVEC(ndofemn,rr));
    ndofe=ndofemn;
  }
  else{
    //  there are no hanging nodes on element
    reallocv (RSTCKIVEC(ndofe,cn));
    reallocv (RSTCKVEC(ndofe,rr));
  }
  //  code numbers on element
  Mt->give_code_numbers (eid,cn.a);
  
  switch (Mp->tprob){
  case forced_dynamics:
  case mech_timedependent_prob:{
    //  lcid must be equal to zero
    for (i=0;i<ndofe;i++){
      ii=cn[i];
      if (ii<0)   
        rr[i]=Mb->dlc[lcid].get_pd(Mp->time, ii);
    }
    break;
  }

  case mat_nonlinear_statics:{
    for (i=0;i<ndofe;i++){
      ii=cn[i];
      if (ii<0)
      {   
        rr[i]=Mb->lc[lcid].pd[0-ii-1];
        if ((lcid % 2) == 0) // the proportional load case is each 1-st, 3-rd, 5-th, ... => lcid = 0, 2, 4,...
          rr[i]*=Mp->lambda;
      } 
    }
    break;
  }
    
  case growing_mech_structure:{
    //  lcid must be equal to zero
    
    //  loop over the number of DOFs on element (including DOFs in hanging nodes)
    for (i=0;i<ndofe;i++){
      ii=cn[i];
      if (ii<0)   
        rr[i]=Mb->dlc[lcid].get_pd(Mp->time, ii);
    }    
    // initial displacements from previous free state of dof 
    // in the case that the dof has got support or prescribed displacement actually
    // must not be included to the computation of the right hand side because 
    // the displacements of the neighbour free dofs are already included in the 
    // displacement vector (r) as well as in the load vector from the previous time step (fp)
    break;
  }
    
  default:{
    for (i=0;i<ndofe;i++){
      ii=cn[i];
      if (ii<0)   
        rr[i]=Mb->lc[lcid].pd[0-ii-1];
    }
  }
  }//  end of the switch (Mp->tprob)
  
  //  the variables ndofe and ndofemn have to be obtained again
  //  because they are possibly rewritten
  //
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs without hanging nodes
  ndofe = Mt->give_ndofe (eid);
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
  ndofemn = Gtm->give_ndofe (eid);
  
  if (ndofe != ndofemn){
    //  there are hanging nodes on element
    mxv (Mt->elements[eid].tmat->a,rr.a,r,ndofe,ndofemn);
  }
  else{
    //  there are no hanging nodes on element
    copyv (rr,r);
  }
  
  
  if (Mp->tprob == growing_mech_structure){
    //  subtraction of initial displacements
    Mt->elements[eid].subtrinitdispl (r,ndofe);
  }
  
}


/**
  The function extracts prescribed displacements on one element.
   
  @param lcid - number of load case
  @param eid - element id
  @param r - array of prescribed displacements, it is output parameter
  
  @return The function returns extracted prescribed displacements in the array r from previous time step. Only for time-dependent problems.

  20/04/2023 by TKr according to JK
*/
 void elprevprdispl (long lcid,long eid,double *r)
{
  long i,ii,ndofe,ndofemn;
  double oldtime;
  ivector cn,nod,ncn;
  vector rr;
  
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs without hanging nodes
  ndofe = Mt->give_ndofe (eid);
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
  ndofemn = Gtm->give_ndofe (eid);
  
  if (ndofe != ndofemn){
    //  there are hanging nodes on element
    reallocv (RSTCKIVEC(ndofemn,cn));
    reallocv (RSTCKVEC(ndofemn,rr));
    ndofe=ndofemn;
  }
  else{
    //  there are no hanging nodes on element
    reallocv (RSTCKIVEC(ndofe,cn));
    reallocv (RSTCKVEC(ndofe,rr));
  }
  //  code numbers on element
  Mt->give_code_numbers (eid,cn.a);
  
  switch (Mp->tprob){
  case forced_dynamics:
  case mech_timedependent_prob:{
    oldtime = Mp->time-Mp->timecon.backwarddt;
    //  lcid must be equal to zero
    for (i=0;i<ndofe;i++){
      ii=cn[i];
      if (ii<0)   
        rr[i]=Mb->dlc[lcid].get_pd(oldtime, ii);
    }
    break;
  }
    
  case growing_mech_structure:{
    oldtime = Mp->time-Mp->timecon.backwarddt;
    //  lcid must be equal to zero
    
    //  loop over the number of DOFs on element (including DOFs in hanging nodes)
    for (i=0;i<ndofe;i++){
      ii=cn[i];
      if (ii<0)   
        rr[i]=Mb->dlc[lcid].get_pd(oldtime, ii);
    }    
    // initial displacements from previous free state of dof 
    // in the case that the dof has got support or prescribed displacement actually
    // must not be included to the computation of the right hand side because 
    // the displacements of the neighbour free dofs are already included in the 
    // displacement vector (r) as well as in the load vector from the previous time step (fp)
    break;
  }
    
  default:{
    print_err("unknown type of problem is required", __FILE__, __LINE__, __func__);
  }
  }//  end of the switch (Mp->tprob)
  
  //  the variables ndofe and ndofemn have to be obtained again
  //  because they are possibly rewritten
  //
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs without hanging nodes
  ndofe = Mt->give_ndofe (eid);
  //  the number of DOFs on element
  //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
  ndofemn = Gtm->give_ndofe (eid);
  
  if (ndofe != ndofemn){
    //  there are hanging nodes on element
    mxv (Mt->elements[eid].tmat->a,rr.a,r,ndofe,ndofemn);
  }
  else{
    //  there are no hanging nodes on element
    copyv (rr,r);
  }
  
  
  if (Mp->tprob == growing_mech_structure){
    //  subtraction of initial displacements
    Mt->elements[eid].subtrinitdispl (r,ndofe);
  }
  
}



/**
  The function extracts displacements on one node with the index nid and stores them in the %vector r.

  @param lcid  - number of load case
  @param r     - allocated array for displacement, it is output parameter
  @param nid   - node number (node id)

  @return The function returns nodal displacements at the given node in the array r.

  Created by JK 9.7.2001
  Modified by Tomas Koudelka
*/
void noddispl (long lcid,double *r, long nid)
{
  long i,j,ndofn,ndofnm,nmn,maxndofnm;
  double **rr;
  vector w;
  
  //  the number of DOFs in node
  ndofn = Gtm->give_ndofn(nid);
  
  if (ndofn<0){
    //  this is a hanging node
    
    //  the number of master nodes
    nmn=0-ndofn;
    
    rr = new double* [nmn];
    //  loop over the number of master nodes
    maxndofnm = -1;
    for (i=0;i<nmn;i++){
      //  the number of DOFs on master node
      ndofnm = Gtm->give_ndofn (Gtm->gnodes[nid].mnodes[i]);
      if (ndofnm > maxndofnm)
        maxndofnm = ndofnm;
      rr[i] = new double [ndofnm];
      select_noddispl (lcid,rr[i],Gtm->gnodes[nid].mnodes[i]);
    }
    
    //  weights
    reallocv (RSTCKVEC(nmn,w));
    Gtm->approx_weights (Gtm->gnodes[nid].masentity,nid,w);
    
    //  approximation
    //r = new double [ndofnm];
    for (i=0; i<maxndofnm; i++)
      r[i] = 0.0;
    
    for (i=0; i<nmn; i++){
      ndofnm = Gtm->give_ndofn (Gtm->gnodes[nid].mnodes[i]);
      for (j=0; j<ndofnm; j++){
	r[j] += rr[i][j]*w[i];
      }
    }
    
    for (i=0;i<0-ndofn;i++){
      delete [] rr[i];
    }
    delete [] rr;
    
    ndofn = ndofnm;
  }else{
    //  this is not a hanging node
    
    //r = new double [ndofn];
    
    select_noddispl (lcid,r,nid);
  }//  end of the statement if (ndofn<0){
  
  //return ndofn;
}



/**
  The function selects nodal displacements of the nid-th node and stores them
  into the %vector r.
   
  @param lcid - load case id
  @param r - array of nodal displacements
  @param nid - node id

  @return The function returns selected nodal displacements in the argument r.
   
  20. 8. 2012, JK
*/
void select_noddispl (long lcid,double *r,long nid)
{
  long i, ii, ndofn;
  
  ndofn = Mt->give_ndofn(nid);

  switch (Mp->tprob){
  case forced_dynamics:
  {
    for (i=0; i<ndofn; i++)
    {
      ii=Mt->give_dof(nid,i);
      if (ii<0){
	r[i] = Mb->dlc[lcid].get_pd(Mp->time, ii);
        if (Mb->lc[lcid].npd > 0)
	  r[i] += Mb->lc[lcid].pd[0-ii-1];
      }
      if (ii==0)  r[i] = 0.0;
      if (ii>0)   r[i] = Lsrs->lhs[lcid*Ndofm+ii-1];
    }
    break;
  }
  case mech_timedependent_prob:
  {
    for (i=0; i<ndofn; i++)
    {
      ii=Mt->give_dof(nid,i);
      if (ii<0)   r[i]=Mb->dlc[lcid].get_pd(Mp->time, ii);
      if (ii==0)  r[i]=0.0;
      if (ii>0)   r[i]=Lsrs->lhs[lcid*Ndofm+ii-1];
    }
    break;
  }
  case growing_mech_structure:
    for (i=0; i<ndofn; i++)
    {
      ii=Mt->give_dof(nid,i);
      if (ii<0)   r[i]=Mb->dlc[lcid].get_pd(Mp->time, ii);
      if (ii==0)  r[i]=0.0;
      if (ii>0)   r[i]=Lsrs->lhs[lcid*Ndofm+ii-1];

      if (Mt->nodedispl[nid] && (ii < 1)) 
      // add initial displacements from previous free state of dof 
      // in the case that the dof has got support or prescribed displacement actually
        r[i] += Mt->nodedispl[nid][i];
    }
    break;
  case mat_nonlinear_statics:{
    for (i=0; i<ndofn; i++){
      ii=Mt->give_dof(nid,i);
      if (ii<0)
      {   
        r[i] = 0.0;
        if (Mb->lc[lcid].npd)
          r[i] += Mb->lc[lcid].pd[0-ii-1] * Mp->lambda;
        if (Mb->lc[lcid+1].npd)
          r[i]+= Mb->lc[lcid+1].pd[0-ii-1];
      }
      if (ii==0)  r[i]=0.0;
      if (ii>0)   r[i]=Lsrs->lhs[lcid*Ndofm+ii-1];
    }
    break;
  }
  default:{
    for (i=0; i<ndofn; i++){
      ii=Mt->give_dof(nid,i);
      if (ii<0)   r[i]=Mb->lc[lcid].pd[0-ii-1];
      if (ii==0)  r[i]=0.0;
      if (ii>0)   r[i]=Lsrs->lhs[lcid*Ndofm+ii-1];
    }
  }
  }//  end of the switch (Mp->tprob){
}



/**
   The function selects nodal forces of the nid-th node from the global vector of nodal forces f
   and stores them into %vector nf.
   
   @param lcid - load case id
   @param nf - array of nodal force component
   @param f - load/internal force %vector
   @param nid - node id
   
   4.4. 2016, TKo
*/
void nodforce (double *f, double *nf, long nid)
{
  long i, j, ii, nmn, mnid, ndofn, ndofnm, maxndofnm;
  double **ff;
  vector w;
  
  //  the number of DOFs in node
  ndofn = Gtm->give_ndofn(nid);

  if (ndofn<0){
    //  this is a hanging node
    
    //  the number of master nodes
    nmn=0-ndofn;
    ff = new double*[nmn];
    //  loop over the number of master nodes
    maxndofnm = -1;
    for (i=0; i<nmn; i++)
    {
      //  the number of DOFs on master node
      mnid   = Gtm->gnodes[nid].mnodes[i];
      ndofnm = Gtm->give_ndofn(mnid);
      if (ndofnm > maxndofnm)
        maxndofnm = ndofnm;
      ff[i]  = new double[ndofnm];
      for (j=0; j<Mt->give_ndofn(mnid); j++)
      {
        ii = Mt->give_dof(mnid,j);
        if (ii<=0)   ff[i][j] = Mt->nodes[mnid].r[j];
        else         ff[i][j] = f[ii-1];
      }
    }
    
    //  weights
    reallocv(RSTCKVEC(nmn,w));
    Gtm->approx_weights (Gtm->gnodes[nid].masentity, nid, w);
    
    //  approximation
    //r = new double [ndofnm];
    for (i=0; i<maxndofnm; i++)
      nf[i]=0.0;
      
    for (i=0; i<nmn; i++){
      mnid   = Gtm->gnodes[nid].mnodes[i];
      ndofnm = Gtm->give_ndofn(mnid);
      for (j=0; j<ndofnm; j++){
	nf[j] += ff[i][j]*w[i];
      }
    }
    
    for (i=0;i<0-ndofn;i++){
      delete [] ff[i];
    }
    delete [] ff;
    
    ndofn = ndofnm;
  }else{
    //  this is not a hanging node
    for (i=0; i<Mt->give_ndofn(nid); i++)
    {
      ii = Mt->give_dof(nid,i);
      if (ii<=0)   nf[i]=Mt->nodes[nid].r[i];
      if (ii>0)    nf[i]=f[ii-1];
    }
  }//  end of the statement if (ndofn<0){
}



/**
  The function returns cn-th component of the macro-strain %vector in case of homogeniztaion problem.

  @param lcid - load case id
  @param cn - index of required macro-strain component

  @return The function returns the given macro-strain component.

  Created by Tomas Koudelka, 20.1.2015
*/
double macrostrains(long lcid, long cn)
{
  long ncomp = Mt->max_ncompstr;
  double *d;
  long *mstress_cn;
  strastre *mstrastre;
  double ret = 0.0;

  switch (Mp->homog){
    case 3:
    case 5:
    case 7: {// macro-stress approach - 
      // components of the macro-strains are at last positions in the %vector of unknowns
      d = Lsrs->give_lhs(lcid);
      ret = d[Ndofm-ncomp+cn];
      break;
    }
    case 4:
    case 6:
    case 8: { // macro-strain approach - macro-strains are defined in the particular load cases
      if (Mb->dlc)
        ret = Mb->dlc[lcid].get_macrostra(Mp->time, cn);
      else{
        if (Mp->tprob == mat_nonlinear_statics){
          ret = Mb->lc[2*lcid].mstrain[cn]*Mp->lambda;
          ret += Mb->lc[2*lcid+1].mstrain[cn];
        }
        else
          ret = Mb->lc[lcid].mstrain[cn];
      }
      break;
    }
    case 9:
      mstrastre = Mb->give_mstrastre(lcid);
      if (mstrastre[cn] == stress){// macro-stress has been applied in the cn direction
        mstress_cn = Mb->give_mstress_cn(lcid);
        d = Lsrs->give_lhs(lcid);
        ret = d[mstress_cn[cn]-1];
      }
      else{
        if (Mb->dlc)
          ret = Mb->dlc[lcid].get_macrostra(Mp->time, cn);
        else{
          if (Mp->tprob == mat_nonlinear_statics){
            ret = Mb->lc[2*lcid].mstrain[cn]*Mp->lambda;
            ret += Mb->lc[2*lcid+1].mstrain[cn];
          }
          else
            ret = Mb->lc[lcid].mstrain[cn];
        }
      }
      break;
    default:{
      print_err("unknown type of homogenization is required", __FILE__, __LINE__, __func__);
      abort();
    }
  }
  return ret;
}



/**
  The function returns the macro-strain %vector in case of homogeniztaion problem.

  @param lcid - load case id
  @param meps - macro-strain %vector in Voigt notation

  @return The function returns macro-strain in the argument meps.

  Created by Tomas Koudelka, 09.2023
*/
void macrostrains(long lcid, vector &meps)
{
  long ncomp = Mt->max_ncompstr;
  double *d;
  long *mstress_cn;
  strastre *mstrastre;
  long i;

  switch (Mp->homog){
    case 3:
    case 5:
    case 7: {// macro-stress approach - 
      // components of the macro-strains are at last positions in the %vector of unknowns
      d = Lsrs->give_lhs(lcid);
      copyv(d+Ndofm-ncomp, meps);
      break;
    }
    case 4:
    case 6:
    case 8: { // macro-strain approach - macro-strains are defined in the particular load cases
      if (Mb->dlc)
        Mb->dlc[lcid].get_macrostra(Mp->time, meps);
      else{
        if (Mp->tprob == mat_nonlinear_statics){
          copyv(Mb->lc[2*lcid].mstrain, meps);
          cmulv(Mp->lambda, meps);
          vector aux;
          makerefv(aux, Mb->lc[2*lcid+1].mstrain, ncomp);
          addv(meps, aux, meps);
        }
        else
          copyv(Mb->lc[lcid].mstrain, meps);
      }
      break;
    }
    case 9:
      mstrastre = Mb->give_mstrastre(lcid);
      for(i=0; i<ncomp; i++){
        if (mstrastre[i] == stress){// macro-stress has been applied in the i-th direction
          mstress_cn = Mb->give_mstress_cn(lcid);
          d = Lsrs->give_lhs(lcid);
          meps(i) = d[mstress_cn[i]-1];
        }
        else{
          if (Mb->dlc)
            meps(i) = Mb->dlc[lcid].get_macrostra(Mp->time, i);
          else{
            if (Mp->tprob == mat_nonlinear_statics){
              meps(i)  = Mb->lc[2*lcid].mstrain[i]*Mp->lambda;
              meps(i) += Mb->lc[2*lcid+1].mstrain[i];
            }
            else
              meps(i) = Mb->lc[lcid].mstrain[i];
          }
        }
      }
      break;
    default:{
      print_err("unknown type of homogenization is required", __FILE__, __LINE__, __func__);
      abort();
    }
  }
}



/**
  The function returns cn-th component of the macro-stress %vector in case of homogeniztaion problem.

  @param lcid - load case id
  @param cn - index of required macro-strain component

  @return The function returns the given macro-stress component.

  Created by Tomas Koudelka, 20.1.2015
*/
double macrostresses(long lcid, long cn)
{
  double ret = 0.0;
  strastre *mstrastre;


  switch (Mp->homog){
    case 3:
    case 5:
    case 7:{ // macro-stress approach - macro-stresses are defined in the particular load cases
      if (Mb->dlc)
	ret = Mb->dlc[lcid].get_macrostre(Mp->time, cn);
      else{
        if (Mp->tprob == mat_nonlinear_statics){
          ret = Mb->lc[2*lcid].mstress[cn]*Mp->lambda;
          ret += Mb->lc[2*lcid+1].mstress[cn];
        }
        else
          ret = Mb->lc[lcid].mstress[cn];
      }
      break;
    }
    case 4:
    case 6:
    case 8:{// macro-strain approach - components of the macro-stresses are stored in mechmat::mstress
      ret = Mm->mstress[cn];
      break;
    }
    case 9:{ // mixed macro-stress/strain approach
      mstrastre = Mb->give_mstrastre(lcid);
      if (mstrastre[cn] == stress){ // macro-stress approach - macro-stresses are defined in the particular load cases
        if (Mb->dlc)
          ret = Mb->dlc[lcid].get_macrostre(Mp->time, cn);
        else{
          if (Mp->tprob == mat_nonlinear_statics){
            ret = Mb->lc[2*lcid].mstress[cn]*Mp->lambda;
            ret += Mb->lc[2*lcid+1].mstress[cn];
          }
          else
            ret = Mb->lc[lcid].mstress[cn];            
        }
      }
      else{// macro-strain approach - components of the macro-stresses are stored in mechmat::mstress
        ret = Mm->mstress[cn];
      }
      break;
    }
    default:{
      print_err("unknown type of homogenization is required", __FILE__, __LINE__, __func__);
      abort();
    }
  }
  return ret;
}



/**
  The function returns the macro-stress %vector in case of homogeniztaion problem.

  @param lcid - load case id
  @param msig - macro-stress %vector in Voigt notation

  @return The function returns macro-stress %vector in the argument msig.

  Created by Tomas Koudelka, 09.2023
*/
void macrostresses(long lcid, vector &msig)
{
  long i, j;
  strastre *mstrastre;
  long ncomp = Mt->max_ncompstr;


  switch (Mp->homog){
    case 3:
    case 5:
    case 7:{ // macro-stress approach - macro-stresses are defined in the particular load cases
      if (Mb->dlc)
	Mb->dlc[lcid].get_macrostre(Mp->time, msig);
      else{
        for (j=0; j<Mb->nlc; j++){
          if (Mp->tprob == mat_nonlinear_statics){
            copyv(Mb->lc[2*lcid].mstress, msig);
            cmulv(Mp->lambda, msig);
            vector aux;
            makerefv(aux, Mb->lc[2*lcid+1].mstress, ncomp);
            addv(msig, aux, msig);
          }
          else
            copyv(Mb->lc[lcid].mstress, msig);
        }
      }
      break;
    }
    case 4:
    case 6:
    case 8:{// macro-strain approach - components of the macro-stresses are stored in mechmat::mstress
      copyv(Mm->mstress, msig);
      break;
    }
    case 9:{ // mixed macro-stress/strain approach
      mstrastre = Mb->give_mstrastre(lcid);
      for(i=0; i<ncomp; i++){
        if (mstrastre[i] == stress){ // macro-stress approach - macro-stresses are defined in the particular load cases
          if (Mb->dlc)
            msig(i) = Mb->dlc[lcid].get_macrostre(Mp->time, i);
          else{
            for (j=0; j<Mb->nlc; j++){
              if (Mp->tprob == mat_nonlinear_statics){
                msig(i) = Mb->lc[2*lcid].mstress[i]*Mp->lambda;
                msig(i) += Mb->lc[2*lcid+1].mstress[i];
              }
              else
                msig(i) = Mb->lc[lcid].mstress[i];            
            }
          }
        }
        else{// macro-strain approach - components of the macro-stresses are stored in mechmat::mstress
          msig(i) = Mm->mstress[i];
        }
      }
      break;
    }
    default:{
      print_err("unknown type of homogenization is required", __FILE__, __LINE__, __func__);
      abort();
    }
  }
}



/**
  The function extracts nodal force components on one node.

  @param f   - array of components for all nodal forces, it is input parameter
  @param nid - node number (node id)
  @param nf  - vector of nodal force, it is output parameter
  @param react - retrieve reaction components(true) or set zero(false) in cases of nodal prescribed displacement values

  @return The function returns nodal force components at the given node in the %vector nf.

  Created by Tomas Koudelka 1.10.2013
*/
void nodforce (double *f, long nid, vector &nf, bool react)
{
  long i,j,ndofn,ndofnm,nmn,maxndofnm;
  vector *ff;
  vector w;
  
  //  the number of DOFs in node
  ndofn = Gtm->give_ndofn(nid);
  
  if (ndofn<0)
  { //  this is a hanging node
    
    //  the number of master nodes
    nmn=0-ndofn;
    
    ff = new vector[nmn]; // array of force vectors of the master nodes
    
    maxndofnm = -1;
    //  loop over the number of master nodes
    for (i=0;i<nmn;i++)
    {
      //  the number of DOFs on master node
      ndofnm = Gtm->give_ndofn(Gtm->gnodes[nid].mnodes[i]);
      if (maxndofnm < ndofnm)
        maxndofnm = ndofnm;
      reallocv(RSTCKVEC(ndofnm, ff[i]));
      select_nodforce (f, Gtm->gnodes[nid].mnodes[i], ff[i], react);
    }
    
    //  weights
    reallocv(RSTCKVEC(nmn, w));
    Gtm->approx_weights(Gtm->gnodes[nid].masentity, nid, w);
    
    //  approximation
    for (i=0; i<maxndofnm; i++)
      nf[i]=0.0;
    
    for (i=0; i<nmn; i++){
      ndofnm = Gtm->give_ndofn(Gtm->gnodes[nid].mnodes[i]);
      for (j=0; j<ndofnm; j++)
	nf[j] += ff[i][j]*w[i];
    }
    delete [] ff;
    
    ndofn = ndofnm;
  }
  else
  {
    //  this is not a hanging node
    select_nodforce (f, nid, nf, react);
  }
}



/**
   The function selects nodal force from the array f and stores its components to 
   the %vector nf.

   @param f   - array of components for all nodal forces, it is input parameter
   @param nid - node id
   @param nf  - %vector of nodal force
   @param react - retrieve reaction components (true) or zero in cases of nodal prescribed displacement values (false)
   
   1. 10. 2013, TKo
*/
void select_nodforce(double *f, long nid, vector &nf, bool react)
{
  long i,ii;
  
  for (i=0;i<Mt->give_ndofn(nid);i++)
  {
    ii=Mt->give_dof(nid,i);
    if (ii < 1)  // there is prescribed DOF
    { 
      if (Mp->reactcomp && react)    
        nf[i]=Mt->nodes[nid].r[i];
      else                              
        nf[i]=0.0;
    }
    else // there is free DOF
    {
      if (f != NULL)   
        nf[i]=f[ii-1];
      else                
        nf[i]=0.0;
    }
  }
}



/**
  The function extracts displacements on one node for given problem.
   
  @param lcid - number of load case
  @param idn  - node number
  @param p    - pointer on problem
  @param r    - answer - allocated array for displacement
   
  @return The function returns require vector of nodal displacements in the array r.

  Created JK, 11.10.2003
*/
/*
void noddispl (long lcid, long idn, problem *p, double *r)
{
  long i,ii;
  
  switch (p->mp->tprob)
  {
  case forced_dynamics:
  case growing_mech_structure://tady??!!
  case mech_timedependent_prob:
    {
      for (i=0;i<p->gt->give_ndofn (idn);i++){
        ii = p->gt->give_dof(idn,i);
        if (ii<0)   r[i]=p->mb->dlc[lcid].get_pd(p->mp->time, ii);
        if (ii==0)  r[i]=0.0;
        if (ii>0)   r[i]=p->lsrs->lhs[lcid*p->lsrs->ndof+ii-1];
      }
      break;
    }
    case mat_nonlinear_statics:
    {
      for (i=0;i<p->gt->give_ndofn (idn);i++){
        ii = p->gt->give_dof(idn,i);
        if (ii<0)   r[i]=p->mb->lc[lcid].pd[0-ii-1] * p->mp->lambda + p->mb->lc[lcid+1].pd[0-ii-1];
        if (ii==0)  r[i]=0.0;
        if (ii>0)   r[i]=p->lsrs->lhs[lcid*p->lsrs->ndof+ii-1];
      }
      break;
    }
    default:
    {
      for (i=0;i<p->gt->give_ndofn (idn);i++)
      {
         ii = p->gt->give_dof(idn,i);
        if (ii<0)   r[i]=p->mb->lc[lcid].pd[0-ii-1];
        if (ii==0)  r[i]=0.0;
        if (ii>0)   r[i]=p->lsrs->lhs[lcid*p->lsrs->ndof+ii-1];
      }
    }
  }
}
*/


/**
  The function assembles constraint %matrix of one layer on one node.
   
  @param nid - node id
  @param cid - contact id
  @param lcm - local constraint %matrix (output)
   
  @return The function returns constraint %matrix in the parameter lcm.

  Created by JK, 7.12.2002
*/
void constr_matrix (long nid,long cid,matrix &lcm)
{
  long i,idcs;
  crsectype crst;
  double tl,tu;
  
  i=Gtm->lgnodes[nid].nodes[cid-1];
  crst = Mt->nodes[i].crst;
  idcs = Mt->nodes[i].idcs;
  tl = Mc->give_onethickness (crst,idcs);
  i=Gtm->lgnodes[nid].nodes[cid];
  crst = Mt->nodes[i].crst;
  idcs = Mt->nodes[i].idcs;
  tu = Mc->give_onethickness (crst,idcs);
  
  fillm (0.0,lcm);

  if (Mp->tlm==1){
    lcm[0][0] = -1.0;
    lcm[1][1] = -1.0;
    lcm[2][0] = tl/(-2.0);
    
    lcm[3][0] = 1.0;
    lcm[4][1] = 1.0;
    lcm[5][0] = tu/(-2.0);
  }
  
  if (Mp->tlm==2){
    
    /*
      uplne stara verze
      lcm[0][0] = -1.0;
      lcm[1][1] = -1.0;
      lcm[2][2] = -1.0;
      lcm[1][3] = tl/2.0;
      lcm[0][4] = tl/(-2.0);
      lcm[3][5] = -1.0;
      
      lcm[0][6]  = 1.0;
      lcm[1][7]  = 1.0;
      lcm[2][8]  = 1.0;
      lcm[1][9]  = tu/2.0;
      lcm[0][10] = tu/(-2.0);
      lcm[3][11] = 1.0;
    */
    
    
    lcm[0][0] = -1.0;
    lcm[1][1] = -1.0;
    lcm[2][2] = -1.0;
    lcm[3][1] = tl/2.0;
    lcm[4][0] = tl/(-2.0);
    lcm[5][3] = -1.0;
    
    lcm[6][0]  = 1.0;
    lcm[7][1]  = 1.0;
    lcm[8][2]  = 1.0;
    lcm[9][1]  = tu/2.0;
    lcm[10][0] = tu/(-2.0);
    lcm[11][3] = 1.0;
  }
}



/**
  Function assembles right hand side of system of algebraic equations.
  It is created by prescribed displacements, forces, moments, eigenstrains, etc.
  and it contains nodal forces.
  In case that the flv is not NULL, %vector of load caused by forces only is stored in flv 
   
  Array rhs has to be cleaned in this function, called functions
  do not clean the array rhs.
   
  @param lcid - load case id
  @param rhs - array of right hand side
  @param flv - array of load %vector caused by forces only (default value is NULL)
   
  @return The function returns assembled vectors of righ hand side and load vector caused by force.

  Created by JK,
  Modified by Tomas Koudelka,
*/
void mefel_right_hand_side (long lcid,double *rhs,double *flv)
{

  double *estc; // pointer to righ hand side vector of load case where to add contributions from eigenstrains/eigenstresses
  
  // by default, the eigenstrain/eigenstress contributions are added to the rhs directly
  estc = rhs;

  if (flv)
    nullv(flv, Ndofm);

  // clean possible thermal strains at integration points because they have been recalculated
  // because they are added by to Mm->tempstrains array by thermal expansion models
  Mm->nulltempstrains();

  switch (Mp->tprob){
  case linear_statics:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+lcid*Ndofm,Ndofm);
    Mb->lc[lcid].assemble (lcid,rhs+lcid*Ndofm,flv,1.0);
    estc = rhs + lcid*Ndofm;
    break;
  }
  case linear_stability:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+lcid*Ndofm,Ndofm);
    Mb->lc[lcid].assemble (lcid,rhs+lcid*Ndofm,flv,1.0);
    estc = rhs + lcid*Ndofm;
    break;
  }
  case eigen_dynamics:{
    break;
  }
  case forced_dynamics:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+lcid*Ndofm,Ndofm);
    //Mb->lc[lcid].assemble (lcid,av);
    Mb->dlc[lcid].assemble (lcid,rhs,flv,Ndofm,Mp->time);
    estc = rhs + lcid*Ndofm;
    break;
  }
  case mat_nonlinear_statics:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+(lcid*2+0)*Ndofm, Ndofm);
    nullv (rhs+(lcid*2+1)*Ndofm, Ndofm);
    if (flv)
      nullv (flv+(lcid*2+1)*Ndofm, Ndofm);
    Mb->lc[lcid*2+0].assemble (lcid*2,rhs+(lcid*2+0)*Ndofm,flv+(lcid*2+0)*Ndofm,1.0);
    Mb->lc[lcid*2+1].assemble (lcid*2,rhs+(lcid*2+1)*Ndofm,flv+(lcid*2+1)*Ndofm,1.0);
    estc = rhs+(lcid*2+1)*Ndofm; // eigenstrain/eigenstress contribution will be contained in the constant load vector
    break;
  }
  case geom_nonlinear_statics:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+(lcid*2+0)*Ndofm, Ndofm);
    nullv (rhs+(lcid*2+1)*Ndofm, Ndofm);
    Mb->lc[lcid*2+0].assemble (lcid*2+0,rhs+(lcid*2+0)*Ndofm,flv,1.0);
    Mb->lc[lcid*2+1].assemble (lcid*2+1,rhs+(lcid*2+1)*Ndofm,flv,1.0);
    estc = rhs+(lcid*2+1)*Ndofm; // eigenstrain/eigenstress contribution will be contained in the constant load vector
    break;
  }
  case mech_timedependent_prob:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+lcid*Ndofm, Ndofm);
    Mb->dlc[lcid].assemble (lcid,rhs+lcid*Ndofm,flv,Ndofm,Mp->time);
    estc = rhs + lcid*Ndofm;
    break;
  }
  case growing_mech_structure:{
    //  lcid must be equal to zero

    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs, Ndofm);
    Mb->dlc[lcid].assemble (0,rhs,flv,Ndofm,Mp->time);
    break;
  }
  case earth_pressure:{
    
    break;
  }
  case layered_linear_statics:{
    
    break;
  }
  case lin_floating_subdomain:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+lcid*Ndofm,Ndofm);
    Mb->lc[lcid].assemble (lcid,rhs+lcid*Ndofm,flv,1.0);
    break;
  }
  case nonlin_floating_subdomain:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+(lcid*2+0)*Ndofm, Ndofm);
    nullv (rhs+(lcid*2+1)*Ndofm, Ndofm);
    Mb->lc[lcid*2+0].assemble (lcid*2+0,rhs+(lcid*2+0)*Ndofm,flv,1.0);
    Mb->lc[lcid*2+1].assemble (lcid*2+1,rhs+(lcid*2+1)*Ndofm,flv,1.0);
    estc = rhs+(lcid*2+1)*Ndofm; // eigenstrain/eigenstress contribution will be contained in the constant load vector
    break;
  }
    
  case hemivar_inequal:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+lcid*Ndofm,Ndofm);
    Mb->lc[lcid].assemble (lcid,rhs+lcid*Ndofm,flv,1.0);
    break;
  }
  case load_balancing:{
    //  components of the vector rhs must be set to zero
    //  function assemble adds contributions to the input vector
    nullv (rhs+lcid*Ndofm,Ndofm);
    Mb->lc[lcid].assemble (lcid,rhs+lcid*Ndofm,flv,1.0);
    break;
  }
    
  default:{
    print_err("unknown problem type is required",__FILE__,__LINE__,__func__);
  }
  }
  
  if (Mp->eigstrains > 0){
    //  contribution to the right hand side (vector of nodal forces)
    //  from prescribed eigenstrains
    
    //  type of eigenstrain is prescribed eigenstrain
    Mm->est=eigstrain;
    
    //  computation of nodal forces caused by eigenstrains
    nodal_eigstrain_forces (lcid,estc,Mp->time);
  }

  if ((Mp->pore_press > 0) && (Mp->pore_press < 3))
  {   
    // For defined values of pore presures or for partially coupled approach,
    // the contribution of nodal forces due to pore pressure is assumed in the right hand side 
    nodal_pore_press_forces (lcid, rhs+lcid*Ndofm, Mp->time);
  }
}



/**
  The function computes all required values
  this function is called e.g. before output print.

  @param lcid - load case id

  @return The function does not return anything.

  Created by JK, 1.4.2004
  Modified by TKo, 07.2008
*/
void compute_req_val (long lcid)
{
  long aux, i, j, tnipel, ipp, jj;

  // strain computaion
  if (Mp->straincomp == 1)
  {
    if (Mp->strainstate==0)
    {
      compute_ipstrains (lcid);
      //  indicator of strain computation
      //  it means, strains at integration points have been computed
      Mp->strainstate=1;
    }
    if (Mp->strainpos == 2)
      compute_nodestrains (lcid);
  }
  
  // stress computaion
  if (Mp->stresscomp == 1)
  {
    // strains have to be computed if they are not computed yet
    if (Mp->strainstate==0)
    {
      compute_ipstrains (lcid);
      //  indicator of strain computation
      //  it means, strains at integration points have been computed
      Mp->strainstate=1;
    }
    if (Mp->stressstate==0)
    {
      compute_ipstresses (lcid);
      //  indicator of stress computation
      //  it means, stresses at integration points have not been computed
      Mp->stressstate=1;
      //  indicator of computation of other array
      //  it means, stresses at integration points have not been computed
      Mp->otherstate=1;
      if (Mp->tprob == linear_statics){
        Mm->updateipval();
      }
    }
    if (Mp->stresspos == 2)
      compute_nodestresses (lcid);
    if (Mb->give_num_mstrain_comp(lcid)) // homogenization based on the prescribed macro-strain approach
    {
      if ((Mp->tprob==linear_statics) && (Mp->strainstate!=0)){
	compute_ipstrains (lcid);//temporarily only for lssolver
	compute_ipstresses (lcid);//temporarily only for lssolver
      }

      memset(Mm->mstress, 0, sizeof(*Mm->mstress)*Mm->max_ncompstre);

      for (i=0;i<Mt->ne;i++){
	if (Gtm->leso[i]==1){
	  if(Mt->give_elem_type (i) == planeelementlq)
	    tnipel = 4;//only the first block for quadrilateral elelemnts 
	  else
	    tnipel = Mt->give_tnip(i);
	  ipp = Mt->elements[i].ipp[0][0];
	  for(j=0;j<tnipel;j++){
	    
	    for (jj=0; jj<Mm->max_ncompstre; jj++)
	      Mm->mstress[jj]+=Mm->ip[ipp].stress[jj]*Mm->ipv[ipp];
	    
	    ipp++;
	  }
	}
      }
      
      for (j=0; j<Mm->max_ncompstre; j++)
	Mm->mstress[j]/=Mt->domvol;
    }
  }
  
  // other values computation
  if ((Mp->othercomp == 1) && (Mp->otherpos == 2) && (Mp->otherstate==1))
    compute_nodeothers ();
  
  //  reactions computation
  if (Mp->reactcomp==1){
    // strains have to be computed at integration points
    if (Mp->strainstate==0)
    {
      compute_ipstrains (lcid);
      //  indicator of strain computation
      //  it means, strains at integration points have been computed
      Mp->strainstate=1;
    }
    if (Mp->stressstate==0)
    {
      compute_ipstresses (lcid);
      //  indicator of stress computation
      //  it means, stresses at integration points have not been computed
      Mp->stressstate=1;
      //  indicator of computation of other array
      //  it means, stresses at integration points have not been computed
      Mp->otherstate=1;
      if (Mp->tprob == linear_statics){
        Mm->updateipval();
      }
    }
    aux = Mp->strcomp;
    Mp->strcomp = 0; // stresses have been already computed, no stress computation 
                     // is required in the integration of forces on the elements
    Mt->null_react();
    switch (Mp->tprob){
    case linear_statics:
    case load_balancing:
    case lin_floating_subdomain:
      Mb->lc[lcid].compute_reactions(lcid, 1.0, yes);
      break;
    case mat_nonlinear_statics:
    case earth_pressure:
    case nonlin_floating_subdomain:
      // Reactions from proportional load case involve contributions from internal forces contributions
      Mb->lc[lcid].compute_reactions(lcid, Mp->lambda, yes);
      // Reaction contributions from constant load case must NOT involve contributions from internal forces contributions
      // otherwise they will be assumed twice. Parameter lcid is not used in the such case
      Mb->lc[lcid+1].compute_reactions(lcid, 1.0, no); 
      break;
    case forced_dynamics:
    case mech_timedependent_prob:
    case growing_mech_structure:
      Mb->dlc[lcid].compute_reactions(lcid);
      break;
    case eigen_dynamics:
      break; 
    default:
      print_err("unknown type of problem is required",__FILE__,__LINE__,__func__);
    }
    Mp->strcomp = aux; // restore the default state
  }

  // computation of strains have to be last due to total strains
  // all previous computations need strains - eigenstrains
  if (Mp->straincomp == 1){
    if (Mp->strainstate==0)
    {
      compute_ipstrains (lcid);
      //  indicator of strain computation
      //  it means, strains at integration points have been computed
      Mp->strainstate=1;
    }
    // in previous statements, strains were modified
    // such that the eigstrains and temprstrains were subtracted
    // total strains have to be computed again    
    Mm->totstrains ();
    if (Mp->strainpos == 2)
      compute_nodestrains (lcid);
  }
}



/**
  The function computes reactions for the given load case.

  @param lcid - required load case id

  @return The function does not return anything but it rewrites reaction array at nodes with the actual values.

  Created by Tomas Koudelka, 15.2.2019
*/
void compute_reactions(long lcid)
{
  long aux;
  aux = Mp->strcomp;
  Mp->strcomp = 0; // stresses are assumed to be already computed, no stress computation 
                   // is required in the integration of forces on the elements
  Mt->null_react();
  switch (Mp->tprob){
    case linear_statics:
    case load_balancing:
    case lin_floating_subdomain:
      Mb->lc[lcid].compute_reactions(lcid, 1.0, yes);
      break;
    case mat_nonlinear_statics:
    case earth_pressure:
    case nonlin_floating_subdomain:
      // Reactions from proportional load case involve contributions from internal forces contributions
      Mb->lc[lcid].compute_reactions(lcid, Mp->lambda, yes);
      // Reaction contributions from constant load case must NOT involve contributions from internal forces contributions
      // otherwise they will be assumed twice. Parameter lcid is not used in the such case
      Mb->lc[lcid+1].compute_reactions(lcid, 1.0, no); 
      break;
    case forced_dynamics:
    case mech_timedependent_prob:
    case growing_mech_structure:
      Mb->dlc[lcid].compute_reactions(lcid);
      break;
    case eigen_dynamics:
      break; 
    default:
      print_err("unknown type of problem is required",__FILE__,__LINE__,__func__);
  }
  Mp->strcomp = aux; // restore the default state
}



/**
  The function transforms nodal displacements form the nodal local coordinate system
  to the global one.

  @param lcid - load case id

  @return The function does not return anything.

  Created by JK,
*/
void local_global_displ_transf (long lcid)
{
  long i,j,k,ndofn;
  ivector cn;
  vector l,g;
  matrix tm(ASTCKMAT(3,3));
  
  for (i=0;i<Mt->nn;i++){
    if (Mt->nodes[i].transf>0){

      //fprintf (Outm,"\n uzel %ld   %ld",i,Mt->nodes[i].transf);

      ndofn = Mt->give_ndofn (i);
      reallocv (RSTCKVEC(ndofn,l));
      reallocv (RSTCKVEC(ndofn,g));
      
      noddispl (lcid,l.a,i);

      tm[0][0]=Mt->nodes[i].e1[0];
      tm[1][0]=Mt->nodes[i].e1[1];
      tm[2][0]=Mt->nodes[i].e1[2];
      
      tm[0][1]=Mt->nodes[i].e2[0];
      tm[1][1]=Mt->nodes[i].e2[1];
      tm[2][1]=Mt->nodes[i].e2[2];
      
      tm[0][2]=Mt->nodes[i].e3[0];
      tm[1][2]=Mt->nodes[i].e3[1];
      tm[2][2]=Mt->nodes[i].e3[2];
      
      mxv(tm,l,g);
      
      reallocv(RSTCKIVEC(ndofn, cn));
      Mt->give_node_code_numbers (i,cn.a);
      
      for (j=0;j<ndofn;j++){
	k=cn[j]-1;
	if (k>-1)
	  Lsrs->lhs[k]=g[j];
      }
    }
  }
}



/**
  The function compute stresses due to initial displacements on the interfaces 
  between new and old part of the structure. It is used due to correct graphics 
  representation of the deformed shape in case of the growing structures.

  Parameters:
  @param lcid - load case id

  @return The function deos not return anything but changes stress array of integration 
          points on active elements.

  Created by TKo, 7.6.2013
*/
void stress_initdispl(long lcid)
{
  long i, j, ne, tnip, ncomp, ipp;
  matrix d;
  vector eps, sig;

  compute_ipstrains(lcid);
  ne = Mt->ne;
  for (i=0;i<ne;i++)
  {
    if (Gtm->leso[i]==1)
    {
      tnip = Mt->give_tnip(i);
      ipp = Mt->elements[i].ipp[0][0];
      for (j=0; j<tnip; j++)
      {
        ncomp = Mm->ip[ipp].ncompstr;
        reallocm(RSTCKMAT(ncomp, ncomp, d));
        reallocv(RSTCKVEC(ncomp, eps));
        reallocv(RSTCKVEC(ncomp, sig));     
        Mm->matstiff(d, ipp);
        Mm->givestrain(lcid, ipp, eps);
        mxv(d, eps, sig);
        Mm->storestress(lcid, ipp, sig);
        ipp++;
      }
    }
  }

  //  indicator of strain computation
  //  it means, strains at integration points have been computed
  Mp->strainstate=1;
  //  indicator of stress computation
  //  it means, stresses at integration points have been computed
  Mp->stressstate=1;
  //  indicator of computation of other array
  //  it means, stresses at integration points have been computed
  Mp->otherstate=1;
}



/**
  The function prints nodal values of active DOFs stored in the 
  nodal value %vector v (dimension of v is Ndofm) to the opened text file out.

  @param v[in] - nodal value %vector
  @param label[in] - string with the %vector v name/label
  @param out[in] - pointer to the opened text output file

  @return The function does not return anything.

  Created ny Tomas Koudelka, 09.2021
*/
void print_nodval_vec(const double *v, const char *label, FILE *out)
{
  long i, j, ndofn, ii;
  
  for (i=0; i<Mt->nn; i++){
    ndofn = Mt->give_ndofn(i);
    fprintf(out, "\n%s[%ld]", label, i+1);
    for(j=0; j<ndofn; j++){
      ii = Mt->give_dof(i, j);
      if (ii > 0){
        ii--;
        fprintf(Out, " % le", v[ii]);
      }
      else{
        fprintf(Out, " %14s", "--- ");
      }
    }
  }
  fprintf(Out, "\n");
}


void check_hex_iface_elem()
{
  vector x(ASTCKVEC(8));
  vector y(ASTCKVEC(8));
  vector z(ASTCKVEC(8));
  matrix tmat(ASTCKMAT(3,3));
  long i,j, nip, nne, cerr = 0;
  double v, vt;
  
  for(i=0; i<Mt->ne; i++){
    nne = Mt->give_nne(i);
    reallocv(RSTCKVEC(nne, x));
    reallocv(RSTCKVEC(nne, y));
    reallocv(RSTCKVEC(nne, z));
    Gtm->give_node_coord3d(x, y, z, i);
    if (Mt->elements[i].te == hexintface){
      Hexifc->coord_transf_matrix(tmat, x, y, z);
      for (j=0; j<nne/2; j++){
        x(j) += tmat(0,2);
        y(j) += tmat(1,2);
        z(j) += tmat(2,2);
      }
    }
    nip = Mt->give_tnip(i);
    vector gp(ASTCKVEC(nip)), w(ASTCKVEC(nip));
    gauss_points (gp.a, w.a, 2);
    vt = 0;
    jac_3d (v, x, y, z, gp[0], gp[0], gp[0]);
    vt += v;
    jac_3d (v, x, y, z, gp[0], gp[0], gp[1]);
    vt += v;
    jac_3d (v, x, y, z, gp[0], gp[1], gp[0]);
    vt += v;
    jac_3d (v, x, y, z, gp[0], gp[1], gp[1]);
    vt += v;
    jac_3d (v, x, y, z, gp[1], gp[0], gp[0]);
    vt += v;
    jac_3d (v, x, y, z, gp[1], gp[0], gp[1]);
    vt += v;
    jac_3d (v, x, y, z, gp[1], gp[1], gp[0]);
    vt += v;
    jac_3d (v, x, y, z, gp[1], gp[1], gp[1]);
    vt += v;
    if (vt < 0.0){
      fprintf(Out, "\nNegative Jacobian (%le) on element %ld.", vt, i+1);
      if (Mt->elements[i].te == hexintface)
        fprintf(stdout, "\nNegative Jacobian (vt=%le, b3=[%le, %le, %le]) on hexiface element %ld.", vt, tmat(0,2), tmat(1,2), tmat(2,2), i+1);
      else
        fprintf(stdout, "\nNegative Jacobian (vt=%le) on element %ld.", vt, i+1);
      cerr++;
    }
    else
      fprintf(Out, "\nElement Jacobian vt=%le on element %ld.", vt, i+1);
    fflush(Out);
  }
  if (cerr > 0){   
    fprintf(stdout, "\nNegative Jacobian detected on %ld elements\n", cerr);
    fflush(stdout);
    abort();
  }
}
