#include <stdlib.h>
#include <errno.h>
#include "globmatt.h"
#include "globalt.h"
#include "lhsrhst.h"
#include "constrel.h"
#include "onemedium.h"
#include "twomedia.h"
#include "threemedia.h"
#include "fourmedia.h"
#include "elemswitcht.h"
#include "ipmap.h"

/**
   function assembles conductivity %matrix of the problem
   
   @param lcid - load case id
*/
void conductivity_matrix (long lcid)
{
  long i,ndofe, ndofemn;
  ivector cn;
  matrix alm, lm, rm;
  
  if (Kmat==NULL)  Kmat = new gmatrix;
  //Kmat->ts=(storagetype)(*(int*)&Tp->tstorkm);
  Kmat->setval (Tp->ssle);
  Kmat->initiate (Gtt,Ndoft,Tp->tstorkm,Mesprt,Outt);
  
  if (Tp->react==1){
    //  if reaction term is included, the reaction matrix has to
    //  be added to the conductivity matrix
    //  the following variable defines which material parameter will
    //  be used in function capacity_matrix on elements
    //  after the end of the loop, the variable has to be set up to the original value
    Tp->react_capac=reaction;
  }
  
  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs without hanging nodes
      ndofe = Tt->give_ndofe (i);
      
      reallocm (RSTCKMAT(ndofe,ndofe,lm));
      //  conductivity matrix of one element
      conductmat (i,lcid,lm);

      if (Tp->react==1){
	//  reaction matrix of one element
	reallocm (RSTCKMAT(ndofe,ndofe,rm));
	reactmat (i,lcid,rm);
	//  sum of conductivity and reaction matrices
	addm (lm,rm,lm);
      }
      
      check_math_errel(i);      

      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtt->give_ndofe (i);
      reallocv (ndofemn, cn);
      Tt->give_code_numbers (i, cn.a);
      if (ndofe == ndofemn)
        //  localization of element matrix to the global matrix for elements with regular nodes
        Kmat->localize (lm,cn,i);
      else{
        //  this case means hanging nodes
        //  the element contains hanging nodes
        //  the conductivity matrix has to be transformed
        reallocm (RSTCKMAT(ndofe, ndofemn, alm));
        mxm (lm, *Tt->elements[i].tmat, alm);
        reallocm (RSTCKMAT(ndofemn, ndofemn, lm));
        mtxm (*Tt->elements[i].tmat, alm, lm);
        Kmat->localize (lm,cn,i);
      }
    }
  }
  
  //  the variable react_capac has to be returned to the original value
  Tp->react_capac=capacity;
  
  Kmat->prepmat (0.0,Mesprt);
}

/**
   function assembles capacity %matrix of the problem

   @param lcid - load case id
*/
void capacity_matrix (long lcid)
{
  long i,ndofe, ndofemn;
  ivector cn;
  matrix lm, alm;
  
  if (Cmat==NULL)  Cmat = new gmatrix;
  //Cmat->ts=(storagetype)(*(int*)&Tp->tstorcm);
  Cmat->setval (Tp->ssle);
  Cmat->initiate (Gtt,Ndoft,Tp->tstorcm,Mesprt,Outt);

  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  number of DOFs on element
      ndofe = Tt->give_ndofe (i);
      
      reallocm (RSTCKMAT(ndofe,ndofe,lm));
      //  capacity matrix of one element
      capacmat (i,lcid,lm);

      check_math_errel(i);      
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtt->give_ndofe (i);
      reallocv (RSTCKIVEC(ndofemn, cn));
      Tt->give_code_numbers (i, cn.a);
      
      if (ndofe == ndofemn)
        //  localization of element matrix to the global matrix for elements with regular nodes
        Cmat->localize (lm,cn,i);
      else{
        //  this case means hanging nodes
        //  the element contains hanging node
        //  the capacity matrix has to be transformed
        reallocm (RSTCKMAT(ndofe, ndofemn, alm));
        mxm (lm, *Tt->elements[i].tmat, alm);
        reallocm (RSTCKMAT(ndofemn, ndofemn, lm));
        mtxm (*Tt->elements[i].tmat, alm, lm);
        Cmat->localize (lm,cn,i);
      }
    }
  }
  
  Cmat->prepmat (0.0,Mesprt);
}





/**
   @param r - %vector of residuum
   @param p - %vector d_{n+1} - d_{n}
   @param v - auxiliary %vector
   @param dt - actual time increment
   @param lcid - load case id
   
   JK, 2.2.2003
*/
/*
void residuum (double *r,double *p,double *v,double dt,long n,long lcid)
{
  capacity_matrix (0);
  conductivity_matrix (0);
  trfel_right_hand_side (0,Lsrst->rhs,Ndoft);
  
  Cmat->gmxv (p,v);
  cmulv (1.0/dt,v,n);
  Kmat->gmxv (Lsrst->lhs,r);
  addv (r,v,n);
  subv (r,Lsrst->rhs,n);
}
*/

/**
  The function computes and extracts values on one element of PUC.

  @param eid[in] - element id
  @param r[out] - %vector of nodal values on element

  @return The function stores extracted nodal values in the argument r.
   
  TKr, 08/09/2010
  Rewritten by TKo, 20.7.2018
*/
void elemvalues_puc (long eid, vector &r)
{
  long i, ii, nne, k, ndofn;
  ivector enod;
  vector rd;

  //  number of nodes on element
  nne = Tt->give_nne (eid);
  reallocv (RSTCKIVEC(nne, enod));
  Tt->give_elemnodes (eid, enod);

  //updating of unknown from master unknown, gradients and fluctuation part
  ii = 0;
  for (i=0; i<nne; i++){
    k = enod[i];
    ndofn = Tt->give_ndofn(k);
    reallocv(RSTCKVEC(ndofn, rd));
    nodalval(k, rd);

    // compute master value contributions and add them to regular nodal values rd
    nodalval_puc_mastercont(k, rd);
    // store nodal values at i-th element node to element nodal value vector r
    memcpy(r.a+ii, rd.a, sizeof(*r.a)*ndofn);
    // compute index of element nodal value vector r for the next node
    ii += ndofn;
  }
}



/**
  The function computes contributions to nodal values at one node of PUC element from master unknown, 
  gradient and fluctuation part.

  @param nid[in] - node id
  @param r[in/out] - %vector of nodal values, on the input it must contain regular nodal values

  @return The function adds computed contributions from master unknown, gradients and fluctuation part at one node to the argument r.

  Created by TKo according to TKr, 20.7.2018  
*/
void nodalval_puc_mastercont(long nid, vector &r)
{
  long i, j;
  long ncomp = Tt->nodes[nid].ncompgrad;
  long ndofn = Tt->give_ndofn(nid);
  vector p(ASTCKVEC(ncomp));

  //added by TKr 07/09/2017
  //nodal coordinates with respect to master node coordinates
  p[0] = Gtt->gnodes[nid].x - Gtt->gnodes[Tt->mnn].x;
  p[1] = Gtt->gnodes[nid].y - Gtt->gnodes[Tt->mnn].y;
  p[2] = Gtt->gnodes[nid].z - Gtt->gnodes[Tt->mnn].z;

  for (i=0; i<ndofn; i++){
    r[i] += Tb->lc[i].masterval;
    for(j=0; j<ncomp; j++){
      r[i] += Tb->lc[i].mastergrad[j]*p[j];
    }
  }
}



/**
  The function computes/extracts nodal values on one element.

  @param eid[in] - element id
  @param r[out] - %vector of nodal values on the given element

  @return The function stores computed nodal values on element in the argument r.

  9.7.2001
  Rewritten by TKo, 20.7.2018
*/
void elemvalues (long eid, vector &r)
{
  long i, nne, k, ii, ndofn;
  ivector enod;
  vector rd;

  //  number of nodes on element
  nne = Tt->give_nne (eid);
  reallocv (RSTCKIVEC(nne, enod));
  Tt->give_elemnodes (eid, enod);

  //updating of unknown from master unknown, gradients and fluctuation part
  ii = 0;
  for (i=0; i<nne; i++){
    k = enod[i];
    ndofn = Tt->give_ndofn(k);
    reallocv(RSTCKVEC(ndofn, rd));
    nodalval(k, rd);

    if (Tp->homogt == 1){
      // compute master value contributions and add them to regular nodal values rd
      nodalval_puc_mastercont(k, rd);
    }

    // store nodal values at i-th element node to element nodal value vector r
    memcpy(r.a+ii, rd.a, sizeof(*r.a)*ndofn);
    // compute index of element nodal value vector r for the next node
    ii += ndofn;
  }
}


/**
  The function extracts values of all nodal unknowns at one node.
   
  @param nid[in] - node id
  @param r[out] - %vector of extracted nodal values
  
  @return The function returns extracted/computed nodal values in the argument r.

  9.7.2001
  Rewritten by TKo, 23.7.2018
*/
void nodalval (long nid, vector &r)
{
  long i, j, nmn, ndofn, ndofnm;
  vector rr;
  
  //  the number of DOFs in node
  ndofn = Gtt->give_ndofn (nid);
  
  if (ndofn >= 0){
    //this is a regular node
    select_nodalval(nid, r);
  }
  else{
    //  this is a hanging node    

    nmn=0-ndofn; //  the number of master nodes
    nullv(r);
    //  loop over the number of master nodes
    for (i=0;i<nmn;i++){
      //  the number of DOFs on master node
      ndofnm = Gtt->give_ndofn(Gtt->gnodes[nid].mnodes[i]);
      reallocv(RSTCKVEC(ndofnm, rr));
      // extract nodal values at i-th master node
      select_nodalval(Gtt->gnodes[nid].mnodes[i], rr);
      // compute contributions from i-th master node
      for (j=0; j<ndofnm; j++)
        r[j] += rr[j]*((*Tt->nodes[nid].mnw)[i]);
    }
  }
}



/**
  The function selects nodal values of the nid-th regular node and stores them
  into the %vector r.

  @param nid[in] - node id
  @param r[out] - %vector of extracted nodal values
  
  @return  The function stores selected nodal values in the argument r.

  9.7.2001
  Renamed by TKo, 23.07.2018
*/   
void select_nodalval (long nid, vector &r)
{
  long i, ii, ndofn;
  
  //  the number of DOFs in node
  ndofn = Tt->give_ndofn (nid);

  switch (Tp->tprob){
  case stationary_problem:{
    for (i=0;i<ndofn;i++){
      ii=Tt->give_dof (nid,i);
      if (ii<0){
	r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
      }
      if (ii==0){
	r[i]=0.0;
      }
      if (ii>0){
	r[i]=Lsrst->lhs[ii-1];
      }
    }
    break;
  }
  case nonlinear_stationary_problem:{
    for (i=0;i<ndofn;i++){
      ii=Tt->give_dof (nid,i);
      if (ii<0){
	r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
      }
      if (ii==0){
	r[i]=0.0;
      }
      if (ii>0){
	if(Tp->homogt == 1)
	  r[i]=Lsrst->lhs[ii-1];
	else
	  r[i]=Lsrst->lhsi[ii-1]+Lsrst->lhs[ii-1];
      }
    }
    break;
  }
  case nonstationary_problem:
  case nonlinear_nonstationary_problem:
  case discont_nonstat_problem:
  case discont_nonlin_nonstat_problem:
  case growing_np_problem:
  case growing_np_problem_nonlin:{
    
    for (i=0;i<ndofn;i++){
      ii=Tt->give_dof (nid,i);
      if (ii<0){
	r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
      }
      if (ii==0){
	r[i]=0.0;
      }
      if (ii>0){   
	r[i]=Lsrst->lhsi[ii-1]+Lsrst->lhs[ii-1];
      }
    }
    break;
  }
  default:{
    print_err("unknown problem type is required",__FILE__,__LINE__,__func__);
  }
  }
}



/**
  The function extracts selected DOF value on one node.
   
  @param nid[in] - regular node id
  @param dofid[in] - selected DOF id
  
  @return The function returns DOF value at the given node. 

  Created by TKo, 23.7.2018
*/
double nodalval (long nid, long dofid)
{
  long i, nmn, ndofn;
  double av, v;
  
  //  the number of DOFs in node
  ndofn = Gtt->give_ndofn (nid);
  
  if (ndofn >= 0){
    // this is a regular node
    v = select_nodalval(nid, dofid);
  }
  else{
    //  this is a hanging node

    nmn = 0-ndofn;  //  the number of master nodes
    v = 0.0;
    //  loop over the number of master nodes
    for (i=0;i<nmn;i++){
      // extract nodal values at i-th master node
      av = select_nodalval(Gtt->gnodes[nid].mnodes[i], dofid);
      // compute contributions from i-th master node
      v += av*((*Tt->nodes[nid].mnw)[i]);
    }
  }

  return v;
}



/**
  The function extracts selected DOF value on one regular node.
   
  @param nid - regular node id
  @param dofid - selected DOF id
  
  @return The function returns DOF value at the given node. 

  Created by JK, 13. 11. 2013
  Renamed by TKo, 23.07.2018
*/
double select_nodalval (long nid, long dofid)
{
  long ii;
  double v=0.0;
  
  switch (Tp->tprob){
  case stationary_problem:{
    ii=Tt->give_dof (nid,dofid);
    if (ii<0){
      v=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
    }
    if (ii==0){
      v=0.0;
    }
    if (ii>0){
      v=Lsrst->lhs[ii-1];
    }
    break;
  }
  case nonlinear_stationary_problem:{
    ii=Tt->give_dof (nid,dofid);
    if (ii<0){
      v=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
    }
    if (ii==0){
      v=0.0;
    }
    if (ii>0){
      if(Tp->homogt == 1)
	v=Lsrst->lhs[ii-1];
      else
	v=Lsrst->lhsi[ii-1]+Lsrst->lhs[ii-1];
    }
    break;
  }
  case nonstationary_problem:
  case nonlinear_nonstationary_problem:
  case discont_nonstat_problem:
  case discont_nonlin_nonstat_problem:
  case growing_np_problem:
  case growing_np_problem_nonlin:{
    
    ii=Tt->give_dof (nid,dofid);
    if (ii<0){
      v=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
    }
    if (ii==0){
      v=0.0;
    }
    if (ii>0){   
      v=Lsrst->lhsi[ii-1]+Lsrst->lhs[ii-1];
    }
    break;
  }
  default:{
    print_err("unknown problem type is required",__FILE__,__LINE__,__func__);
  }
  }
  return v;
}



/**
  The function extracts initial values at one node
   
  @param nid[in] - node number
  @param r[out]  - %vector of nodal values

  @return The function stores nodal values in argument r.

  Created by TKo, 23.07.2018
*/
void initnodval (long nid, vector &r)
{
  long i, j, nmn, ndofn, ndofnm;
  vector rr;
  
  //  the number of DOFs in node
  ndofn = Gtt->give_ndofn (nid);
  
  if (ndofn >= 0){
    //this is a regular node
    select_nodalval(nid, r);
  }
  else{
    //  this is a hanging node    

    nmn=0-ndofn; //  the number of master nodes
    nullv(r);
    //  loop over the number of master nodes
    for (i=0;i<nmn;i++){
      //  the number of DOFs on master node
      ndofnm = Gtt->give_ndofn(Gtt->gnodes[nid].mnodes[i]);
      reallocv(RSTCKVEC(ndofnm, rr));
      // extract nodal values at i-th master node
      select_initnodval(Gtt->gnodes[nid].mnodes[i], rr);
      // compute contributions from i-th master node
      for (j=0; j<ndofnm; j++)
        r[j] += rr[j]*((*Tt->nodes[nid].mnw)[i]);
    }
  }
}



/**
  The function extracts initial values at one regular node
   
  @param nid[in] - node number
  @param r[out]  - %vector of nodal values

  @return The function stores nodal values in the argument r.

  Create by JK, 18.8.2008
  Renamed by TKo, 23.07.2018
*/
void select_initnodval (long nid, vector &r)
{
  long i, ii, ndofn;
  
  ndofn = Tt->give_ndofn(nid);
  switch (Tp->tprob){
  case nonlinear_stationary_problem:
  case nonstationary_problem:{
    for (i=0; i<ndofn; i++){
      ii=Tt->give_dof(nid,i);
      if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
      if (ii==0)  r[i]=0.0;
      if (ii>0){   
	r[i]=Lsrst->lhsi[ii-1];
      }
    }
    
    break;
  }
  case nonlinear_nonstationary_problem:{
    for (i=0; i<ndofn; i++){
      ii=Tt->give_dof(nid,i);
      if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
      if (ii==0)  r[i]=0.0;
      if (ii>0){   
	r[i]=Lsrst->lhsi[ii-1];
      }
    }
    
    break;
  }
  case discont_nonstat_problem:
  case discont_nonlin_nonstat_problem:{
    for (i=0; i<ndofn; i++){
      ii=Tt->give_dof(nid,i);
      if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
      if (ii==0)  r[i]=0.0;
      if (ii>0){   
	r[i]=Lsrst->lhsi[ii-1];
      }
    }
    
    break;
  }
    
  case growing_np_problem:
  case growing_np_problem_nonlin:{
    for (i=0; i<ndofn; i++){
      ii=Tt->give_dof(nid, i);
      if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
      if (ii==0)  r[i]=0.0;
      if (ii>0){   
	r[i]=Lsrst->lhsi[ii-1];
      }
    }
    
    break;
  }
  default:{
    print_err("unknown problem type is required",__FILE__,__LINE__,__func__);
  }
  }
}



/**
  The function extracts initial values at one node, initial values at nodes with 
  prescribed values are taken from ipv of the given boundary condition.
   
  @param nid[in] - node number
  @param r[out]  - %vector of nodal values

  @return The function stores nodal values in argument r.

  Created by TKo, 23.07.2018
*/
void initnodval2(long nid, vector &r)
{
  long i, j, nmn, ndofn, ndofnm;
  vector rr;
  
  //  the number of DOFs in node
  ndofn = Gtt->give_ndofn (nid);
  
  if (ndofn >= 0){
    //this is a regular node
    select_nodalval(nid, r);
  }
  else{
    //  this is a hanging node    

    nmn=0-ndofn; //  the number of master nodes
    nullv(r);
    //  loop over the number of master nodes
    for (i=0;i<nmn;i++){
      //  the number of DOFs on master node
      ndofnm = Gtt->give_ndofn(Gtt->gnodes[nid].mnodes[i]);
      reallocv(RSTCKVEC(ndofnm, rr));
      // extract nodal values at i-th master node
      select_initnodval2(Gtt->gnodes[nid].mnodes[i], rr);
      // compute contributions from i-th master node
      for (j=0; j<ndofnm; j++)
        r[j] += rr[j]*((*Tt->nodes[nid].mnw)[i]);
    }
  }
}



/**
  The function extracts initial values at one regular node, initial values at nodes with 
  prescribed values are taken from ipv of the given boundary condition.
   
  @param nid[in] - node number
  @param r[out]  - %vector of nodal values

  TKo, 5.6.2018
  Renamed by TKo, 23.7.2018
*/
void select_initnodval2 (long nid, vector &r)
{
  long i, ii, ndofn;
  
  ndofn = Tt->give_ndofn(nid);
  switch (Tp->tprob){
    case nonlinear_stationary_problem:
    case nonstationary_problem:
      for (i=0; i<ndofn; i++){
        ii=Tt->give_dof(nid,i);
        if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].ipv;
        if (ii==0)  r[i]=0.0;
        if (ii>0){   
          r[i]=Lsrst->lhsi[ii-1];
        }
      }
      break;
    case nonlinear_nonstationary_problem:
      for (i=0; i<ndofn; i++){
        ii=Tt->give_dof(nid,i);
        if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].ipv;
        if (ii==0)  r[i]=0.0;
        if (ii>0){   
          r[i]=Lsrst->lhsi[ii-1];
        }
      }
      break;
    case discont_nonstat_problem:
    case discont_nonlin_nonstat_problem:
      for (i=0; i<ndofn; i++){
        ii=Tt->give_dof(nid,i);
        if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].ipv;
        if (ii==0)  r[i]=0.0;
        if (ii>0){   
          r[i]=Lsrst->lhsi[ii-1];
        }
      }
      break;
    case growing_np_problem:
    case growing_np_problem_nonlin:
      for (i=0; i<ndofn; i++){
        ii=Tt->give_dof(nid,i);
        if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].ipv;
        if (ii==0)  r[i]=0.0;
        if (ii>0){   
          r[i]=Lsrst->lhsi[ii-1];
        }
      }
      break;
    default:
      print_err("unknown problem type is required",__FILE__,__LINE__,__func__);
  }
}



/**
  The function extracts values from previous step on one regular node.
  This function differs from the function nodalval in that
  the %vector of global nodal values is an input parameter while the
  function nodalval uses the %vector Lsrst->lhs.
   
  @param nid[in] - node number
  @param lhs[in] - %vector of values from the previous step
  @param r[out]  - %vector for extracted nodal values
   
  9.7.2001
  Renamed by TKo, 23.07.2018 
*/
void gvnodval (long nid, double *lhs, vector &r)
{
  long i, j, nmn, ndofn, ndofnm;
  vector rr;
  
  //  the number of DOFs in node
  ndofn = Gtt->give_ndofn (nid);
  
  if (ndofn >= 0){
    //this is a regular node
    select_gvnodval(nid, lhs, r);
  }
  else{
    //  this is a hanging node    

    nmn=0-ndofn; //  the number of master nodes
    nullv(r);
    //  loop over the number of master nodes
    for (i=0;i<nmn;i++){
      //  the number of DOFs on master node
      ndofnm = Gtt->give_ndofn(Gtt->gnodes[nid].mnodes[i]);
      reallocv(RSTCKVEC(ndofnm, rr));
      // extract nodal values at i-th master node
      select_gvnodval(Gtt->gnodes[nid].mnodes[i], lhs, rr);
      // compute contributions from i-th master node
      for (j=0; j<ndofnm; j++)
        r[j] += rr[j]*((*Tt->nodes[nid].mnw)[i]);
    }
  }
}



/**
  The function extracts values on the given regular node from the global %vector of nodal values.
  This function differs from the function nodalval in that the %vector of global nodal values 
  is an input parameter while the function nodalval uses the %vector Lsrst->lhs.
   
  @param nid[in] - node number
  @param lhs[in] - global %vector of nodal values
  @param r[out]  - %vector for extracted nodal values
   
  9.7.2001
  Renamed by TKo, 23.07.2018 
*/
void select_gvnodval (long nid, double *lhs, vector &r)
{
  long i, ii, ndofn;
  
  ndofn = Tt->give_ndofn (nid);
  switch (Tp->tprob){
    case nonlinear_stationary_problem:
    case nonstationary_problem:
      for (i=0; i<ndofn; i++){
        ii=Tt->give_dof(nid,i);
        if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
        if (ii==0)  r[i]=0.0;
        if (ii>0){   
          r[i]=Lsrst->lhsi[ii-1]+lhs[ii-1];
        }
      }
      break;
    case nonlinear_nonstationary_problem:
      for (i=0; i<ndofn; i++){
        ii=Tt->give_dof(nid,i);
        if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
        if (ii==0)  r[i]=0.0;
        if (ii>0){
          r[i]=Lsrst->lhsi[ii-1]+lhs[ii-1];
        }
      }
      break;
    case discont_nonstat_problem:
    case discont_nonlin_nonstat_problem:
      for (i=0; i<ndofn; i++){
        ii=Tt->give_dof(nid,i);
        if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
        if (ii==0)  r[i]=0.0;
        if (ii>0){   
          r[i]=Lsrst->lhsi[ii-1]+lhs[ii-1];
        }
      }
      break;
    case growing_np_problem:
    case growing_np_problem_nonlin:
      for (i=0; i<ndofn; i++){
        ii=Tt->give_dof(nid,i);
        if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
        if (ii==0)  r[i]=0.0;
        if (ii>0){   
          r[i]=Lsrst->lhsi[ii-1]+lhs[ii-1];
        }
      }
      //  subtraction of initial nodal values
      //Tt->elements[eid].subtrinitnodval (r,Tt->give_ndofn (idn));
      break;
    default:
      print_err("unknown problem type is required",__FILE__,__LINE__,__func__);
  }
}



/**
  The function extracts all values of flux resultants on the given node from
  array ifor
   
  @param gv[in] - array of global nodal value %vector
  @param nid[in] - node id
  @param nf[out]  - %vector of nodal values at node nid

  @return The function returns results in the parameter nf.
   
  Created by Tomas Koudelka 02.2018
*/
void gen_gvnodval (double *gv, long nid, vector &nf)
{
  long i, j, ii, nmn, ndofn, ndofnm;
  vector anf;
  
  //  the number of DOFs in node
  ndofn = Gtt->give_ndofn (nid);
  
  if (ndofn >= 0){
    //this is a regular node

    //  the number of DOFs in the regular node
    ndofn = Tt->give_ndofn (nid);
    for (i=0; i < ndofn; i++)
    {
      ii=Tt->give_dof(nid, i);
      if (ii<0)   nf[i]=0.0;
      if (ii==0)  nf[i]=0.0;
      if (ii>0)   nf[i]=gv[ii-1];
    }
  }
  else{
    //  this is a hanging node    

    nmn=0-ndofn; //  the number of master nodes
    nullv(nf);
    //  loop over the number of master nodes
    for (i=0;i<nmn;i++){
      //  the number of DOFs on master node
      ndofnm = Gtt->give_ndofn(Gtt->gnodes[nid].mnodes[i]);
      reallocv(RSTCKVEC(ndofnm, anf));
      // extract nodal values at i-th master node
      for (j=0; j < ndofnm; j++)
      {
        ii=Tt->give_dof(Gtt->gnodes[nid].mnodes[i], j);
        if (ii<0)   anf[j]=0.0;
        if (ii==0)  anf[j]=0.0;
        if (ii>0)   anf[j]=gv[ii-1];
      }
      // compute contributions from i-th master node
      for (j=0; j<ndofnm; j++)
        nf[j] += anf[j]*((*Tt->nodes[nid].mnw)[i]);
    }
  }
}



/**
  The function extracts required DOF value on the given node from the global %vector gv.
   
  @param gv[in] - array of global nodal value %vector
  @param nid[in]   - node id
  @param dofid[in] - required DOF id (=load case id)

  @return The function returns DOF value at the given node.
   
  Created by Tomas Koudelka 02.2018
*/
double gen_gvnodval(double *gv, long nid, long dofid)
{
  double v = 0.0;
  long ndofn = Gtt->give_ndofn (nid);  //  the number of DOFs in node
  long i, ii, nmn, ndofnm;  

  if (ndofn >= 0){
    //this is a regular node

    ii=Tt->give_dof(nid, dofid);
    if (ii>0)   
      v = gv[ii-1];
  }
  else{
    //  this is a hanging node    

    nmn=0-ndofn; //  the number of master nodes
    //  loop over the number of master nodes
    for (i=0;i<nmn;i++){
      //  the number of DOFs on master node
      ndofnm = Gtt->give_ndofn(Gtt->gnodes[nid].mnodes[i]);
      ii=Tt->give_dof(Gtt->gnodes[nid].mnodes[i], dofid);
      if (ii>0)
        v += gv[ii-1]*((*Tt->nodes[nid].mnw)[i]);
    }
  }
  return v;
}



/**
  The function extracts nodal values stored in array other
  values are extracted for all nodes of required element.
   
  @param nod[in] - list of nodes on element
  @param r[out] - array containing nodal values

  17.9.2005, JK
*/
void nodalotherval (ivector &nod, vector &r)
{
  long i,j,k,ncompo;
  
  k=0;
  for (i=0;i<nod.n;i++){
    ncompo = Tt->nodes[nod[i]].ncompother;
    for (j=0;j<ncompo;j++){
      r[k]=Tt->nodes[nod[i]].other[j];
      k++;
    }
  }
}



/**
  The function extracts first time derivatives of nodal values at the given element.

  @param eid[in] - element id
  @param r[out] - %vector of derivatives of nodal values on one element

  4.3.2003
  Rewritten by Tomas koudelka, 23.07.2018
*/
void nodalderivatives (long eid, vector &r)
{
  long i, nne, ndofn, ii;
  ivector enod;
  vector rr;

  // check whether nodal derivatives are defined in the problem  
  switch (Tp->tprob){
    case nonlinear_stationary_problem:
    case nonstationary_problem:
    case nonlinear_nonstationary_problem:
    case growing_np_problem:
    case discont_nonstat_problem:
    case discont_nonlin_nonstat_problem:
    case growing_np_problem_nonlin:
      break;
    default:
      print_err("unknown problem type is required",__FILE__,__LINE__,__func__);
  }

  nne = Tt->give_nne(eid);
  reallocv(RSTCKIVEC(nne, enod));

  ii = 0;
  for (i=0; i<nne; i++)
  {
    ndofn = Tt->give_ndofn(enod[i]);
    reallocv(RSTCKVEC(ndofn, rr));
    gen_gvnodval(Lsrst->tdlhs, enod[i], rr);
    memcpy(r.a+ii, rr.a, sizeof(*rr.a)*ndofn);
    ii += ndofn;
  }
}



/**
  The function extracts prescribed and initial values on one element. Hanging node handling must 
  be cared in the caller of this function.
   
  @param r[out]    - array of prescribed and initial nodal values on the given element
  @param cn[in]    - array containing code numbers
  @param ndofe[in] - number of DOFs in element

  @return The function returns prescribed/initial nodal values in the argument r.

  21.3.2004, JK
*/
void prescvalues (double *r, long *cn, long ndofe)
{
  long i,ii;
  
  for (i=0;i<ndofe;i++){
    ii=cn[i];
    if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getval(Tp->time);
    if (ii==0)  r[i]=0.0;
    if (ii>0){
      if(Tp->homogt == 1)
	r[i]=0.0;
      else
	r[i]=Lsrst->lhsi[ii-1];
    }
  }
}




/**
  The function extracts prescribed and initial values on one element at the previous time step. Hanging node handling must 
  be cared in the caller of this function.
   
  @param r - %vector of nodal values
  @param cn - array containing code numbers
  @param ndofe - number of DOFs in element
   
   13.4.2018, JK
*/
void prevprescvalues (double *r, long *cn, long ndofe)
{
  long i,ii;
  double t;
  
  //  computation of time at previous step
  t=Tp->time-Tp->timecont.backwarddt;
  
  for (i=0;i<ndofe;i++){
    ii=cn[i];
    if (ii<0)   r[i]=Tb->lc[0].pv[0-ii-1].getprevval(t);
    if (ii==0)  r[i]=0.0;
    if (ii>0){
      if(Tp->homogt == 1)
	r[i]=0.0;
      else
	r[i]=Lsrst->lhsi[ii-1];
    }
  }
}



/**
  The function extracts initial values on one element
   
  @param eid[in] - element id
  @param r[out]  - %vector of nodal values on the given element
   
  @return The function returns initial nodal values of the element in the argument r.

  Created by JK, 21.3.2004
  Rewritten by TKo, 26.7.2018
*/
void initialvalues (long eid, vector &r)
{
  long i, nne, ndofn, cndofn;
  ivector enod;
  vector rr;
  
  nne = Tt->give_nne(eid);
  reallocv(RSTCKIVEC(nne, enod));
  Tt->give_elemnodes(eid, enod);

  cndofn = 0;
  for (i=0; i<nne; i++){
    ndofn = Tt->give_ndofn(enod[i]);
    // make reference vector to the nodal values of i-th element node
    makerefv(rr, r.a+cndofn, ndofn);
    // store initial nodal values of i-th node
    initnodval2(enod[i], rr);
    cndofn += ndofn;
  }
}



/**
   function computes quantity values in integration points of PUC
   values in integration points are obtained from nodal values of PUC
   
   TKr, 08/09/2010
*/
void approximation_puc ()
{
  long i;
  
  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      
      //  interpolation of nodal values to integration points
      intpointvalues_puc (i);
      //  computation of gradients in integration points
      //intpointgradients (i);
    }
  }

  //correction of values in case of incorrect size of PUC
  Tm->values_correction_puc ();

  Tm->aux_values (0);
}


/**
   function computes quantity values in regular integration points
   values in integration points are obtained from nodal values
   
   16.1.2002
*/
void approximation ()
{
  long i,ii,j,ipp,nip;
  
  if (Tp->nvs==1){
    //  copy of nodal values to array nodval on nodes
    //  implementation due to saltmat4
    copy_nodval (0);
  }

  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      
      //  interpolation of nodal values to integration points
      intpointvalues (i);
      //  computation of gradients in integration points
      intpointgradients (i);
    }
  }
  
  Tm->aux_values (0);

  if (Tp->nvs==1){
    //  arrays of actual values are moved to arrays of previous values
    //  implementation due to saltmat4
    //actual_previous_change ();
  }
    
  //pro V. Smilauera prumerovani teplot na prvku a ukladani do pole other na int. bodech 
  //provizorni umisteni ??!!
  if (Tm->cemhydr){
    //nulovani prumernych teplot na materialu
    //nulovani poctu int. bodu materialu
    for (i=0;i<Tm->nmt;i++){
      if (Tm->mattype[i] == cementhydrmat)
	for (j=0;j<Tm->numtype[i];j++){
	  Tm->cemhydr[j].average_temp = 0.0;
	  Tm->cemhydr[j].n_ipp = 0;
	}
    }

    //ukladani teplot do materialu
    //ukladani poctu int. bodu materialu
    for (i=0;i<Tt->ne;i++){
      if (Gtt->leso[i]==1){
	ipp=Tt->elements[i].ipp[0][0];
	nip=Tt->give_tnip (i);
	for (j=0;j<nip;j++){
	  ii = Tm->ip[ipp+j].idm;

	  if(Tp->tmatt == onemedium)
	    Tm->cemhydr[ii].average_temp += Tm->ip[ipp+j].av[0];
	  if(Tp->tmatt == twomediacoup)
	    Tm->cemhydr[ii].average_temp += Tm->ip[ipp+j].av[1];
	  if(Tp->tmatt == threemediacoup)
	    Tm->cemhydr[ii].average_temp += Tm->ip[ipp+j].av[2];
	  
	  Tm->cemhydr[ii].n_ipp++;	  
	}
      }
    }
    
    //prumerovani teplot na materialu
    for (i=0;i<Tm->nmt;i++){
      if (Tm->mattype[i] == cementhydrmat)
	for (j=0;j<Tm->numtype[i];j++){
	  if (Tm->cemhydr[j].n_ipp != 0)
	    Tm->cemhydr[j].average_temp /= Tm->cemhydr[j].n_ipp;
	}
    }

    //ukladani prumernych teplot do materialu
    for (i=0;i<Tt->ne;i++){
      if (Gtt->leso[i]==1){
	ipp=Tt->elements[i].ipp[0][0];
	nip=Tt->give_tnip (i);
	for (j=0;j<nip;j++){
	  ii = Tm->ip[ipp+j].idm;
	  Tm->ip[ipp+j].other[0] = Tm->cemhydr[ii].average_temp;
	}
      }
    }
  }
}



/**
   function computes initial quantity values in regular integration points
   values in integration points are obtained from nodal values
   
   4.7.2018
*/
void initapproximation ()
{
  long i,ii,j,ipp,nip;
  
  if (Tp->nvs==1){
    //  copy of nodal values to array nodval on nodes
    //  implementation due to saltmat4
    copy_nodval (0);
  }
  
  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      
      //  interpolation of nodal values to integration points
      initintpointvalues (i);
      //  computation of gradients in integration points
      intpointgradients (i);
    }
  }
  
  Tm->aux_values (0);
  
  // arrays of actual values are moved to arrays of previous values
  actual_previous_change ();

  if (Tp->nvs==1){
    //  arrays of actual values are moved to arrays of previous values
    //  implementation due to saltmat4
    //actual_previous_change ();
  }
    
  //pro V. Smilauera prumerovani teplot na prvku a ukladani do pole other na int. bodech 
  //provizorni umisteni ??!!
  if (Tm->cemhydr){
    //nulovani prumernych teplot na materialu
    //nulovani poctu int. bodu materialu
    for (i=0;i<Tm->nmt;i++){
      if (Tm->mattype[i] == cementhydrmat)
	for (j=0;j<Tm->numtype[i];j++){
	  Tm->cemhydr[j].average_temp = 0.0;
	  Tm->cemhydr[j].n_ipp = 0;
	}
    }

    //ukladani teplot do materialu
    //ukladani poctu int. bodu materialu
    for (i=0;i<Tt->ne;i++){
      if (Gtt->leso[i]==1){
	ipp=Tt->elements[i].ipp[0][0];
	nip=Tt->give_tnip (i);
	for (j=0;j<nip;j++){
	  ii = Tm->ip[ipp+j].idm;

	  if(Tp->tmatt == onemedium)
	    Tm->cemhydr[ii].average_temp += Tm->ip[ipp+j].av[0];
	  if(Tp->tmatt == twomediacoup)
	    Tm->cemhydr[ii].average_temp += Tm->ip[ipp+j].av[1];
	  if(Tp->tmatt == threemediacoup)
	    Tm->cemhydr[ii].average_temp += Tm->ip[ipp+j].av[2];
	  
	  Tm->cemhydr[ii].n_ipp++;	  
	}
      }
    }
    
    //prumerovani teplot na materialu
    for (i=0;i<Tm->nmt;i++){
      if (Tm->mattype[i] == cementhydrmat)
	for (j=0;j<Tm->numtype[i];j++){
	  if (Tm->cemhydr[j].n_ipp != 0)
	    Tm->cemhydr[j].average_temp /= Tm->cemhydr[j].n_ipp;
	}
    }

    //ukladani prumernych teplot do materialu
    for (i=0;i<Tt->ne;i++){
      if (Gtt->leso[i]==1){
	ipp=Tt->elements[i].ipp[0][0];
	nip=Tt->give_tnip (i);
	for (j=0;j<nip;j++){
	  ii = Tm->ip[ipp+j].idm;
	  Tm->ip[ipp+j].other[0] = Tm->cemhydr[ii].average_temp;
	}
      }
    }
  }
}



/**
  The function computes quantity values in auxiliary integration points
  values in auxiliary integration points are obtained from nodal values
   
  @param n - the number of components in the ipm array [in]
  @param ipm - the array of integration point mapping objects [in]

  @return The function does not return anything but stores computed variable values 
          in particular auxiliary integration points of the transmat aip array.

  Created by Tomas Koudelka, 8.12.2017
*/
void aip_approximation (long n, ipmap *ipm)
{
  intpointst *tmp_ip;
  long *tmp_elip, tmp_tnip;
  double **tmp_ntq;
  double *tmp_iv;
  double val;

  long app, eid, i, j, k;
  long nne, ndofe, ncomp;
  long **dofe, **ordering;
  vector x, y, z, r, t, grad;
  ivector cn;
  matrix gm;

  // swap regular integration point and auxiliary integration point arrays
  // from now, all functions will work with AUXILIARY integration points 
  tmp_ip = Tm->ip;
  tmp_elip = Tm->elip;
  tmp_ntq = Tm->nontransq;
  tmp_iv = Tm->initval;
  tmp_tnip = Tm->tnip;
  Tm->ip = Tm->aip;
  Tm->elip = Tm->elaip;
  Tm->nontransq = Tm->aip_nontransq;
  Tm->initval = Tm->aip_initval;
  Tm->tnip = Tm->tnaip;

  //  loop over elements
  for (i=0; i<n; i++)
  {
    app = ipm[i].app;
    if (app < 0) // direct mapping to the regular integration point => aip values and their gardients have already been computed
      continue;

    eid = Tm->elip[app];
    //  only elements switched on are processed
    if (Gtt->leso[eid]==1){
      // nodal coordinates of the given element
      nne = Tt->give_nne(eid);
      reallocv(RSTCKVEC(nne, x));
      reallocv(RSTCKVEC(nne, y));
      reallocv(RSTCKVEC(nne, z));
      Tt->give_node_coord3d(x, y, z, eid);
      ndofe = Tt->give_ndofe(eid);
      reallocv(RSTCKVEC(ndofe, r));
      reallocv(RSTCKVEC(nne, t));
      // nodal values of all unknowns on element
      elemvalues (eid, r);
      // array of number of element DOFs for particular transported media
      dofe = Tt->give_dofe(eid);
      // ordering of variables in the vector of unknowns
      ordering = Tt->give_ordering(eid);

      for (j=0; j<Tp->ntm; j++) // loop over all variables of transported media
      {
        //  collect nodal values of j-th single variable in the vector t
        for (k=0; k<dofe[j][j]; k++)
          t[k]=r[ordering[j][k]-1];

        // approximation of j-th variable nodal values to the auxiliary int. point
        val = approx (eid, ipm[i].xi, ipm[i].eta, ipm[i].zeta, t);
        Tm->ip[app].av[j]=val;

        // number of gradient components
        ncomp = Tm->ip[app].ncompgrad;
        // allocate gradient matrix
        reallocm(RSTCKMAT(ncomp, nne, gm));
        // allocate resulting gradient vector
        reallocv(RSTCKVEC(ncomp, grad));
        // get the gradient matrix at the given auxiliary integration point
        grad_matrix(eid, x, y, z, ipm[i].xi, ipm[i].eta, ipm[i].zeta, gm);
        // grad t = gm.t
        mxv(gm, t, grad);
        // store gradients at auxiliary integration point app
        Tm->storegrad(j, app, grad);
      }
    }
  }
  
  Tm->aux_values (0);
  

  if (Tp->nvs==1){
    //  arrays of actual values are moved to arrays of previous values
    //  implementation due to saltmat4
    //actual_previous_change ();
  }
    
  // swap regular integration point auxiliary integration point arrays
  // from now, all functions will work with REGULAR integration points 
  Tm->ip = tmp_ip;
  Tm->elip = tmp_elip;
  Tm->nontransq = tmp_ntq;
  Tm->initval = tmp_iv;
  Tm->tnip = tmp_tnip;
}



/**
  The function computes initial quantity values in auxiliary integration points
  initial values in auxiliary integration points are obtained from initial nodal values
   
  @param n - the number of components in the ipm array [in]
  @param ipm - the array of integration point mapping objects [in]

  @return The function does not return anything but stores computed initial variable values 
          in particular auxiliary integration points of the transmat aip array.

  Created by Tomas Koudelka, 13.6.2018
*/
void aip_initapproximation (long n, ipmap *ipm)
{
  intpointst *tmp_ip;
  long *tmp_elip, tmp_tnip;
  double **tmp_ntq;
  double *tmp_iv;
  double val;

  long app, eid, i, j, k, ndofn, cndofn;  
  long nne, ndofe, ncomp;
  long **dofe, **ordering;
  vector x, y, z, r, t, grad, rr;
  ivector enod;
  matrix gm;

  // swap regular integration point and auxiliary integration point arrays
  // from now, all functions will work with AUXILIARY integration points 
  tmp_ip = Tm->ip;
  tmp_elip = Tm->elip;
  tmp_ntq = Tm->nontransq;
  tmp_iv = Tm->initval;
  tmp_tnip = Tm->tnip;
  Tm->ip = Tm->aip;
  Tm->elip = Tm->elaip;
  Tm->nontransq = Tm->aip_nontransq;
  Tm->initval = Tm->aip_initval;
  Tm->tnip = Tm->tnaip;

  //  loop over elements
  for (i=0; i<n; i++)
  {
    app = ipm[i].app;
    if (app < 0) // direct mapping to the regular integration point => aip values and their gardients have already been computed
      continue;

    eid = Tm->elip[app];
    //  only elements switched on are processed
    if (Gtt->leso[eid]==1){
      // nodal coordinates of the given element
      nne = Tt->give_nne(eid);
      reallocv(RSTCKVEC(nne, x));
      reallocv(RSTCKVEC(nne, y));
      reallocv(RSTCKVEC(nne, z));
      Tt->give_node_coord3d(x, y, z, eid);
      ndofe = Tt->give_ndofe(eid);
      reallocv(RSTCKVEC(ndofe, r));
      reallocv(RSTCKVEC(nne, t));
      reallocv(RSTCKIVEC(nne, enod));
      // element nodes
      Tt->give_elemnodes(eid, enod);
      // nodal values of all unknowns on element
      cndofn = 0;
      for (j=0; j<nne; j++)
      { 
        ndofn = Tt->give_ndofn(enod[j]);
        makerefv(rr, r.a+cndofn, ndofn);
        initnodval2 (enod[j], rr);
        cndofn += ndofn;      
      }
      // array of number of element DOFs for particular transported media
      dofe = Tt->give_dofe(eid);
      // ordering of variables in the vector of unknowns
      ordering = Tt->give_ordering(eid);

      for (j=0; j<Tp->ntm; j++) // loop over all variables of transported media
      {
        //  collect nodal values of j-th single variable in the vector t
        for (k=0; k<dofe[j][j]; k++)
          t[k]=r[ordering[j][k]-1];

        // approximation of j-th variable nodal values to the auxiliary int. point
        val = approx (eid, ipm[i].xi, ipm[i].eta, ipm[i].zeta, t);
        Tm->ip[app].av[j]=val;

        // number of gradient components
        ncomp = Tm->ip[app].ncompgrad;
        // allocate gradient matrix
        reallocm(RSTCKMAT(ncomp, nne, gm));
        // allocate resulting gradient vector
        reallocv(RSTCKVEC(ncomp, grad));
        // get the gradient matrix at the given auxiliary integration point
        grad_matrix(eid, x, y, z, ipm[i].xi, ipm[i].eta, ipm[i].zeta, gm);
        // grad t = gm.t
        mxv(gm, t, grad);
        // store gradients at auxiliary integration point app
        Tm->storegrad(j, app, grad);
      }
    }
  }
  
  Tm->aux_values (0);
  

  if (Tp->nvs==1){
    //  arrays of actual values are moved to arrays of previous values
    //  implementation due to saltmat4
    //actual_previous_change ();
  }
    
  // swap regular integration point auxiliary integration point arrays
  // from now, all functions will work with REGULAR integration points 
  Tm->ip = tmp_ip;
  Tm->elip = tmp_elip;
  Tm->nontransq = tmp_ntq;
  Tm->initval = tmp_iv;
  Tm->tnip = tmp_tnip;
}



/**
   function moves arrays with actual values to arrays of previous values at all integration points
   
   JK, 29.5.2007
*/
void actual_previous_change ()
{
  long i;
  
  for (i=0;i<Tm->tnip;i++){
    Tm->ip[i].actual_previous_change ();
  }
}

/**
   function moves arrays with actual values to arrays of previous values at all nodes
   
   JK, 14.1.2008
*/
void actual_previous_nodval ()
{
  long i;
  
  for (i=0;i<Tt->nn;i++){
    Tt->nodes[i].actual_previous_change ();
  }
}

/**
   function assembles part of the %vector of right hand side
   
   @param rhs - right hand side
   
   21.3.2004, JK
*/
void assemble_init (double *rhs)
{
  long i, j, ndofe, ndofemn, lcid=0;
  double dt;
  vector r, pr, f, ra, pra, fa;
  ivector cn;
  matrix km, cm;
  long ne = Tt->ne;
  
  for (i=0;i<ne;i++){
    
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      //  number of DOFs on element
      ndofe=Tt->give_ndofe(i);
      reallocm (RSTCKMAT(ndofe,ndofe,km));
      
      //  computation of element conductivity matrix
      conductmat (i,lcid,km);
      
      check_math_errel(i);      

      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtt->give_ndofe (i);

      reallocv (RSTCKVEC(ndofe,r));
      reallocv (RSTCKVEC(ndofe,pr));
      reallocv (RSTCKVEC(ndofe,f));
      reallocv (RSTCKVEC(ndofemn,ra));
      reallocv (RSTCKVEC(ndofemn,pra));
      reallocv (RSTCKVEC(ndofemn,fa));
      reallocv (RSTCKIVEC(ndofemn, cn));
      
      Gtt->give_code_numbers (i,cn.a);
      
      //  there must be this function (prescvalues)
      //  no other function may be here
      //  only initial values are required
      //  for more details see manual
      prescvalues (ra.a,cn.a,ndofemn);
      
      if ((Tp->tprob !=  stationary_problem) && (Tp->tprob!=nonlinear_stationary_problem)){
	//  this part is used for evaluation of the term C \dot{d}
	
	reallocv (RSTCKVEC(ndofemn,pra));
	
	//  prescribed values from the previous step
	prevprescvalues (pra.a,cn.a,ndofemn);
	dt=Tp->timecont.backwarddt;
	//  approximation of the time derivative of the Dirichlet boundary condition
	for (j=0;j<ndofemn;j++){
	  pra.a[j]=(ra.a[j]-pra.a[j])/dt;
	}
      }
      
      
      if (ndofe == ndofemn) // for regular nodes on element
        copyv(ra, r);
      else  // for hanging nodes on element
        mxv(*Tt->elements[i].tmat, ra, r);
      
      //  nodal values
      mxv (km,r,f);
      cmulv (-1.0,f);     
      
      if (ndofe == ndofemn) // for regular nodes on element
        copyv(f, fa);
      else  // for hanging nodes on element
        mtxv (*Tt->elements[i].tmat, f, fa);
      
      //  localization of nodal values

      locglob (rhs,fa.a,cn.a,ndofemn);
      
      //fprintf(Outt, "\nRight-hand side init vector eid=%ld:\n",i);
      //for (j=0;j<ndofemn;j++){
      //fprintf(Outt, "%e\n",fa[j]);
      //}
      //fflush(Outt);  

      
      if ((Tp->tprob != stationary_problem) && (Tp->tprob != nonlinear_stationary_problem)){
	//  this is contribution from time derivative of prescribed values on boundaries
	
	//  prescribed values at the actual time step
	prescvalues (ra.a,cn.a,ndofemn);
	//  prescribed values from the previous time step
	prevprescvalues (pra.a,cn.a,ndofemn);
	//  the length of time step
	dt=Tp->timecont.forwarddt;
	//  computation of the time derivative of
	for (j=0;j<ndofemn;j++){
	  pra.a[j]=(ra.a[j]-pra.a[j])/dt;
	}
	
	reallocm (RSTCKMAT(ndofe,ndofe,cm));
	capacmat (i,lcid,cm);
	check_math_errel(i);
	
	if (ndofe == ndofemn) // for regular nodes on element
	  copyv(pra, pr);
	else  // for hanging nodes on element
	  mxv(*Tt->elements[i].tmat, pra, pr);
	//  nodal values
	mxv (cm,pr,f);
	cmulv (-1.0,f);
	
	if (ndofe == ndofemn) // for regular nodes on element
	  copyv(f, fa);
	else  // for hanging nodes on element
	  mtxv (*Tt->elements[i].tmat, f, fa);
	
	//  localization of nodal values
	locglob (rhs,fa.a,cn.a,ndofe);

	locglob (rhs,fa.a,cn.a,ndofemn);
	//fprintf(Outt, "\nRight-hand side init vector2 eid=%ld:\n",i);
	//for (j=0;j<ndofemn;j++){
	//fprintf(Outt, "%e\n",fa[j]);
	//}

      }
    }
  }
}

/**
   function assembles right hand side of the problem
   
   @param lcid - load case id
   @param rhs - array containing right hand side
   @param n - number of components of array rhs
   
   12.3.2002
*/
void trfel_right_hand_side (long lcid,double *rhs,long n)
{
  long i, ndofe, ndofemn;
  vector lv, alv;
  ivector cn;
  double *av;
  av = new double [n];
  
  //  all components are set to zero
  nullv (rhs,n);
  
  //  function assembles the part of the right hand side vector
  //  caused by initial conditions and prescribed values
  assemble_init (rhs);
  
  //contribution of gradients for homogenization
  if(Tp->homogt == 1){
    nullv (av,n);
    assemble_gradients_contrib(av);
    addv (rhs,av,n);
  }

  for (i=0; i<Tp->ntm; i++) // loop over all media
  {
    if (Tp->tprob==nonlinear_stationary_problem){
      //
      //  this is a nonlinear stationary case, e.g. homogenization
      //
      if (Tp->ntm > 1) // originally, this code was only for one medium
      {
        print_err("support for %ld media have not been implemented\n"
                  " in nonlinear_stationary_problem", __FILE__, __LINE__, __func__, Tp->ntm);
        abort();
      }
      nullv (av,n);
      copyv (rhs,av,n);
      
      nullv (rhs+(lcid*2+0)*n,n);
      nullv (rhs+(lcid*2+1)*n,n);
      
      Tb->lc[lcid*2+0].assemble (lcid*2+0,rhs+(lcid*2+0)*n);
      addv (rhs,av,n);
      //Tb->lc[lcid*2+1].assemble (lcid*2+1,rhs+(lcid*2+1)*n);
      //addv (rhs+(lcid*2+1)*n,av,n);
    }//  end of the nonlinear stationary case
    else{
      //
      //  components of the vector av must be set to zero
      //  function assemble adds contributions to the input vector
      nullv (av,n);
      Tb->lc[i].assemble(i,av); // ???!!! vyresit kdyz lcid != 0
      addv (rhs,av,n);
    }
  }
  
  //  contributions from volume integrals
  nullv (av,n);
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      
      //  number of DOFs on element
      ndofe=Tt->give_ndofe (i);
      reallocv (RSTCKVEC(ndofe,lv));
      fillv (0.0,lv);
      
      //  function is defined in elemswitcht.cpp
      volume_rhs_vector (lv,lcid,i);

      check_math_errel(i);            
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtt->give_ndofe (i);
      //  code numbers
      reallocv (RSTCKIVEC(ndofemn, cn));
      Gtt->give_code_numbers (i, cn.a);

      if (ndofe == ndofemn){
        //  localization of element values to the global vector for elements with regular nodes
        locglob (av,lv.a,cn.a,ndofe);
      }
      else      
      {
        //  this case means hanging nodes
        //  the element contains hanging nodes
        //  the element value vector has to be transformed
        reallocv (RSTCKVEC(ndofemn, alv));
        mtxv (*Tt->elements[i].tmat, lv, alv);
        locglob (av, alv.a, cn.a, ndofemn);
      }
    }
  }  
  
  addv (rhs,av,n);

  delete [] av;
}


/**
   function assembles right hand side of the problem for mechanical effect - only for partially coupled problem 
   
   @param lcid - load case id
   @param rhs - array containing right hand side
   @param n - number of components of array rhs
   
   16/05/2018, TKr
*/
void trfel_right_hand_side2 (long lcid,double *rhs,long n)
{
  long i, ndofe, ndofemn;
  vector lv, alv;
  ivector cn;
  double *av;
  av = new double [n];
  
  //  all components are set to zero
  //nullv (rhs,n);
  
  //  contributions from volume integrals
  nullv (av,n);
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      
      //  number of DOFs on element
      ndofe=Tt->give_ndofe (i);
      reallocv (RSTCKVEC(ndofe,lv));
      fillv (0.0,lv);
      
      //  function is defined in elemswitcht.cpp
      volume_rhs_vector2 (lv,lcid,i);

      check_math_errel(i);            
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtt->give_ndofe (i);
      //  code numbers
      reallocv (RSTCKIVEC(ndofemn, cn));
      Gtt->give_code_numbers (i, cn.a);

      if (ndofe == ndofemn){
        //  localization of element values to the global vector for elements with regular nodes
        locglob (av,lv.a,cn.a,ndofe);
      }
      else{
        //  this case means hanging nodes
        //  the element contains hanging nodes
        //  the element value vector has to be transformed
        reallocv (RSTCKVEC(ndofemn, alv));
        mtxv (*Tt->elements[i].tmat, lv, alv);
        locglob (av, alv.a, cn.a, ndofemn);
      }
    }
  }  
  
  // vector av is added into rhs vector computed in previous trfel_right_hand_side function
  //fprintf(Outt, "%e",Tp->time);
  //for (i=0;i<n;i++){
  //fprintf(Outt, " %e",av[i]);
  //}
  //fprintf(Outt, "\n");
  //fflush(Outt);  

  addv (rhs,av,n);

  delete [] av;
}


/**
   function assembles flux on the boundary
   
   @param lcid - load case id
   @param iflux - array containing flux (right hand side)
   
   12.3.2002
*/
void trfel_bound_flux (long lcid,double *iflux,long n)
{
  long i;
  double *av;
  av = new double [n];
  
  for(i=0; i<Tp->ntm; i++)
  {
    Tb->lc[lcid+i].assemble_flux (lcid+i,av,n); // ???!!! vyresit kdyz lcid != 0
    addv (iflux,av,n);
    nullv (av,n);
  }
  
  delete [] av;
}


/**
   function computes all required values
   this function is called e.g. before output print

   @param lcid - load case id

   1.4.2004, JK

   01/02/2010 changed by TKr
*/
void compute_req_valt (long /*lcid*/)
{
  //  approximation of nodal values to integration points
   if (Tp->ipvcomp == 0)
     approximation();
  
  // gradient computaion
  if (Tp->gradcomp == 1){
    if (Tp->gradpos==1){
      //  gradients are evaluated in integration points
      compute_ipgrads ();
    }
    if (Tp->gradpos==2){
      //  gradients are evaluated in integration points and they are copied to nodes
      compute_nodegrads ();
    }
    if (Tp->gradpos==3){
      //  gradients are evaluated directly in nodes
      print_err("direct evaluation of gradients in node has not been implemented yet", __FILE__, __LINE__, __func__);
    }
  }
  
  // flux computaion
  if (Tp->fluxcomp == 1){
    if (Tp->gradcomp == 0){
      //  gradients have to be computed before flux evaluation
      print_err("gradients have to be computed before flux evaluation", __FILE__, __LINE__, __func__);
    }
    if (Tp->fluxpos==1){
      //  fluxes are evaluated in integration points
      compute_ipfluxes ();
    }
    if (Tp->fluxpos==2){
      //  fluxes are evaluated in integration points and copied to nodes
      compute_nodefluxes ();
    }
    if (Tp->fluxpos==3){
      //  fluxes are directly computed in nodes
      print_err("direct evaluation of fluxes in node has not been implemented yet", __FILE__, __LINE__, __func__);
    }
  }
  
  if (Tp->tprob == nonlinear_nonstationary_problem ||
      Tp->tprob == nonstationary_problem ||
      Tp->tprob == discont_nonstat_problem ||
      Tp->tprob == discont_nonlin_nonstat_problem ||
      Tp->tprob == growing_np_problem ||
      Tp->tprob == growing_np_problem_nonlin){

    // other computaion
    if (Tp->othercomp==1){
      if (Tp->otherpos==1)
	{
	  //	compute_nodeotherst_comp ();
	  compute_nodeotherst ();
	  compute_ipotherst ();
	}
      if (Tp->otherpos==2)
      	compute_nodeotherst ();
      if (Tp->otherpos==3)//computed directly at nodes
	compute_nodeotherst_comp ();
    }
    
    // eqother computaion
    if (Tp->eqothercomp==1){
      if (Tp->eqotherpos==1)
	compute_ipeqotherst ();
      if (Tp->eqotherpos==2)
	compute_nodeeqotherst ();
      //if (Tp->eqotherpos==3)//computed directly at nodes not implemented yet
      //compute_nodeeqotherst ();
    }

  }
}



/**
  The function assembles vector of nodal values of humidity.
   
  @param gv - vector of humidity nodal values
  @param nodmap - array of nodal correspondence map, nodmap[i] = gv component id of i-th node
 
  Created by TKr
  Modified by TKo 04.2018
*/
void give_nodal_humid (double *gv, long *nodmap)
{
  long i, cn, compother, nn = Tt->nn;
  double *r;
  
  r = new double [Tp->ntm];
  
  switch (Tp->tmatt){
  case onemedium:{
    med1 m1;

    for (i=0;i<nn;i++){
      cn=Tt->give_dof (i,0);
      if (cn>0)  gv[nodmap[i]] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn<0)  gv[nodmap[i]] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);

      gv[nodmap[i]] = m1.compute_othervalues(1,0,r);
      if(gv[nodmap[i]] >= 1.0)
        gv[nodmap[i]] = 1.0;
      
    }
    break;    
  }
  case twomediacoup:{
    med2 m2;
    
    for (i=0;i<nn;i++){
      cn=Tt->give_dof (i,0);
      if (cn>0)  r[0] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn==0) r[0] = 0.0;
      if (cn<0)  r[0] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);
      
      cn=Tt->give_dof (i,1);
      if (cn>0)  r[1] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn==0) r[1] = 0.0;
      if (cn<0)  r[1] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);
      
      compother = 1;
      if ((Tm->ip[0].tm) == kunzel)
	compother = 0;

      gv[nodmap[i]] = m2.compute_othervalues(compother,0,r);
      if(gv[nodmap[i]] >= 1.0)
	gv[nodmap[i]] = 1.0;
    }
    break;
  }
  case threemediacoup:{
    med3 m3;
    
    for (i=0;i<nn;i++){
      cn=Tt->give_dof (i,0);
      if (cn>0)  r[0] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn==0) r[0] = 0.0;
      if (cn<0)  r[0] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);
      
      cn=Tt->give_dof (i,1);
      if (cn>0)  r[1] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn==0) r[1] = 0.0;
      if (cn<0)  r[1] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);
      
      cn=Tt->give_dof (i,2);
      if (cn>0)  r[2] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn==0) r[2] = 0.0;
      if (cn<0)  r[2] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);
      
      gv[nodmap[i]] = m3.compute_othervalues(3,0,r);
      if(gv[nodmap[i]] >= 1.0)
	gv[nodmap[i]] = 1.0;
    }
    break;
  }
  case fourmediacoup:{
    med4 m4;
    
    for (i=0;i<nn;i++){
      cn=Tt->give_dof (i,0);
      if (cn>0)  r[0] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn==0) r[0] = 0.0;
      if (cn<0)  r[0] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);
      
      cn=Tt->give_dof (i,1);
      if (cn>0)  r[1] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn==0) r[1] = 0.0;
      if (cn<0)  r[1] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);
      
      cn=Tt->give_dof (i,2);
      if (cn>0)  r[2] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn==0) r[2] = 0.0;
      if (cn<0)  r[2] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);
      
      cn=Tt->give_dof (i,3);
      if (cn>0)  r[3] = Lsrst->lhsi[cn-1]+Lsrst->lhs[cn-1];
      if (cn==0) r[3] = 0.0;
      if (cn<0)  r[3] = Tb->lc[0].pv[0-cn-1].getval(Tp->time);
      
      gv[nodmap[i]] = m4.compute_othervalues(4,0,r);
      if(gv[nodmap[i]] >= 1.0)
	gv[nodmap[i]] = 1.0;
    }
    break;
  }
  default:{
    print_err("unknown number of transported matters is required",__FILE__,__LINE__,__func__);
  }
  }
  
  delete [] r;
}


/**
   function corrects solution of algebraic system of equations
   unacceptable trial values are replaced by the limit values
   
   14.7.2005
*/
void solution_correction ()
{
  long i,j,k,cn,ne,nne,ndofn,lcid,ipp;
  ivector nodes;
  vector nv;

  //  number of elements
  ne = Tt->ne;
  
  //  load case id, default value is 0
  lcid=0;
  
  //  loop over elements
  for (i=0;i<ne;i++){
    //  number nodes on element
    nne = Tt->give_nne (i);
    
    //  allocation
    reallocv (RSTCKIVEC(nne,nodes));

    //  node numbers on element
    Tt->give_elemnodes (i,nodes);
    
    //  integration point id
    ipp=Tt->elements[i].ipp[0][0];
    
    //  extraction of nodal values    
    for (j=0;j<nne;j++){
      //  number of DOFs on node
      ndofn = Gtt->give_ndofn (nodes[j]);
      if (ndofn < 0)
        continue;
      //  allocation
      reallocv (RSTCKVEC(ndofn,nv));
      //  nodal values
      nodalval (nodes[j], nv);
      //  correction of values
      Tm->values_correction (nv,ipp);

      check_math_errel(1000);

      //  replacement of values in array containing the solution
      for (k=0;k<ndofn;k++){
	cn = Tt->give_dof (nodes[j],k);
	if (cn>0){
	  Lsrst->lhs[cn-1]=nv[k]-Lsrst->lhsi[cn-1];
	}
      }
    }
  }
}



/**
   function computes number of cycles
   the function is intended for computation of frozing cycles
   
   @param plhs - nodal values from previous time step
   @param pplhs - nodal values from time step i-2
   
   11.9.2007, JK
*/
void compute_cycles (double *plhs,double *pplhs)
{
  long i,j,lcid,ndofn,nne,ipp,nc;
  vector r,pr,ppr;
  ivector nod;
  
  //  only one load case can be used
  lcid=0;
  
  if (Tt->ncycl == NULL){
    Tt->ncycl = new long [Tt->nn];
    Tt->aux = new long[Tt->nn];
    
    for (i=0;i<Tt->nn;i++){
      Tt->ncycl[i]=0;
    }
  }
  
  for (i=0;i<Tt->nn;i++){
    Tt->aux[i]=0;
  }
  
  for (i=0;i<Tt->ne;i++){
    //  number of nodes on element
    nne = Tt->give_nne (i);
    reallocv (RSTCKIVEC(nne,nod));
    //  element nodes
    Tt->give_elemnodes (i,nod);
    //  integration point id
    ipp = Tt->elements[i].ipp[0][0];
    
    for (j=0;j<nne;j++){
      if (Tt->aux[nod[j]]>0)
	continue;
      
      //  number of nodal DOF
      ndofn = Tt->give_ndofn (nod[j]);
      reallocv(RSTCKVEC(ndofn, r));
      reallocv(RSTCKVEC(ndofn, pr));
      reallocv(RSTCKVEC(ndofn, ppr));
      //  nodal values
      nodalval (nod[j], r);
      gvnodval (nod[j], plhs, pr);
      gvnodval (nod[j], pplhs, ppr);
      //  cycle detection
      nc=Tm->cycle_detection (r.a,pr.a,ppr.a,ipp);
      
      Tt->ncycl[nod[j]]+=nc;
      Tt->aux[nod[j]]=1;
    }
  }
}


/**
   function copies nodal values from %vector of nodal values (%vector of solution)
   to the array nodval defined on node
   
   @param lcid - load case id
   
   JK, 8.1.2008
*/
void copy_nodval (long /*lcid*/)
{
  long i,ndofn;
  vector r;
  
  //  loop over nodes
  for (i=0;i<Tt->nn;i++){
    //  number of DOFs on node
    ndofn = Tt->give_ndofn (i);
    //  array allocation
    reallocv(RSTCKVEC(ndofn, r));
    //  nodal values
    nodalval (i, r);
    //  save value to array nodval on nodes
    Tt->nodes[i].save_nodval (r.a);
  }
}


/**
   function assembles part of the %vector of right hand side from gradients of PUC
   
   @param rhs - right hand side
   
   19/08/2010, TKr
*/
void assemble_gradients_contrib (double *rhs)
{
  long i, ii, jj, k, ndofe, ndofemn, lcid=0, ntm, ncomp;
  ivector cn;
  vector grad, f, af;
  matrix ltm;
  long ne = Tt->ne;
  

  for (i=0;i<ne;i++){
    
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      
      //  number of DOFs on element
      ndofe=Tt->give_ndofe(i);
      ntm = Tp->ntm;
      ncomp = Tt->give_ncomp(i);
      reallocm (RSTCKMAT(ndofe,ntm*ncomp,ltm));
      
      //  computation of element l_t matrix
      ltmat (i,lcid,ltm);
      
      reallocv (RSTCKVEC(ntm*ncomp,grad));
      reallocv (RSTCKVEC(ndofe,f));
      reallocv (RSTCKIVEC(ndofe, cn));
      
      //  constant gradients
      k = 0;
      for(ii=0;ii<ntm;ii++){
	for(jj=0;jj<ncomp;jj++){
	  grad[k]=Tb->lc[ii].mastergrad[jj];
	  k++;
	}
      }

      //  nodal values
      mxv (ltm,grad,f);
      
      cmulv (-1.0,f);
      
      //  the number of DOFs on element
      //  this number is equal to the number of DOFs with master nodes generated by hanging nodes
      ndofemn = Gtt->give_ndofe (i);
      //  code numbers
      reallocv (RSTCKIVEC(ndofemn, cn));
      Gtt->give_code_numbers (i, cn.a);
      
      if (ndofe == ndofemn){
        //  localization of element nodal values to the global vector for elements with regular nodes
        locglob (rhs, f.a, cn.a, ndofe);
      }
      else{
        //  this case means hanging nodes
        //  the element contains hanging nodes
        //  the element value vector has to be transformed
        reallocv (RSTCKVEC(ndofemn, af));
        mtxv (*Tt->elements[i].tmat, f, af);
        locglob (rhs, af.a, cn.a, ndofemn);
      }
    }
  }
}



/**
   function assembles l %matrix and l_t (transposed) %matrix of PUC
   
   @param lcid - load case id
*/
void assemble_l_matrix (matrix &lm, matrix &ltm)
{
  long i,ndofe,lcid=0,ntm,ncomp;
  ivector rcn, ccn;
  matrix lkm,lkmt;
  
  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      
      //  number of DOFs on element
      ndofe=Tt->give_ndofe(i);
      ntm = Tp->ntm;
      ncomp = Tt->give_ncomp(i);
      reallocm (RSTCKMAT(ndofe,ntm*ncomp,lkmt));
      reallocm (RSTCKMAT(ntm*ncomp,ndofe,lkm));
      
      //  computation of element l_t matrix
      ltmat (i,lcid,lkmt);

      //  computation of element l matrix
      lmat (i,lcid,lkm);

      reallocv(RSTCKIVEC(ndofe, rcn));
      reallocv(RSTCKIVEC(ntm*ncomp, ccn));
      
      Gtt->give_code_numbers (i,rcn.a);
      if((ntm*ncomp) == 1){
	ccn[0] = 1;
      }
      if((ntm*ncomp) == 2){
	ccn[0] = 1;
	ccn[1] = 2;
      }
      if((ntm*ncomp) == 3){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
      }
      if((ntm*ncomp) == 4){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
 	ccn[3] = 4;
      }
      if((ntm*ncomp) == 6){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
 	ccn[3] = 4;
	ccn[4] = 5;
 	ccn[5] = 6;
      }
      if((ntm*ncomp) == 9){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
 	ccn[3] = 4;
	ccn[4] = 5;
 	ccn[5] = 6;
 	ccn[6] = 7;
	ccn[7] = 8;
 	ccn[8] = 9;
      }
      
      //  localization of l_t matrix
      mat_localize (ltm,lkmt,rcn.a,ccn.a);

      //  localization of l matrix
      mat_localize (lm,lkm,ccn.a,rcn.a);      
    }
  }
}



/**
   function assembles l %matrix %matrix of PUC
   
   @param lcid - load case id
*/
void assemble_l_matrix (matrix &lm)
{
  long i,ndofe,lcid=0,ntm,ncomp;
  ivector rcn, ccn;
  matrix lkm;
  
  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      
      //  number of DOFs on element
      ndofe=Tt->give_ndofe(i);
      ntm = Tp->ntm;
      ncomp = Tt->give_ncomp(i);
      reallocm (RSTCKMAT(ntm*ncomp,ndofe,lkm));
      
      //  computation of element l matrix
      lmat (i,lcid,lkm);

      reallocv(RSTCKIVEC(ndofe, rcn));
      reallocv(RSTCKIVEC(ntm*ncomp, ccn));
      
      Gtt->give_code_numbers (i,rcn.a);
      if((ntm*ncomp) == 1){
	ccn[0] = 1;
      }
      if((ntm*ncomp) == 2){
	ccn[0] = 1;
	ccn[1] = 2;
      }
      if((ntm*ncomp) == 3){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
      }
      if((ntm*ncomp) == 4){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
 	ccn[3] = 4;
      }
      if((ntm*ncomp) == 6){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
 	ccn[3] = 4;
	ccn[4] = 5;
 	ccn[5] = 6;
      }
      if((ntm*ncomp) == 9){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
 	ccn[3] = 4;
	ccn[4] = 5;
 	ccn[5] = 6;
 	ccn[6] = 7;
	ccn[7] = 8;
 	ccn[8] = 9;
      }
      
      //  localization of l matrix
      mat_localize (lm,lkm,ccn.a,rcn.a);      
    }
  }
}



/**
   function assembles l_t (transposed) %matrix of PUC
   
   @param lcid - load case id
*/
void assemble_lt_matrix (matrix &ltm)
{
  long i,ndofe,lcid=0,ntm,ncomp;
  ivector rcn, ccn;
  matrix lkmt;
  
  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  only elements switched on are processed
      
      //  number of DOFs on element
      ndofe=Tt->give_ndofe(i);
      ntm = Tp->ntm;
      ncomp = Tt->give_ncomp(i);
      reallocm (RSTCKMAT(ndofe,ntm*ncomp,lkmt));
      
      //  computation of element l_t matrix
      ltmat (i,lcid,lkmt);

      reallocv(RSTCKIVEC(ndofe, rcn));
      reallocv(RSTCKIVEC(ntm*ncomp, ccn));
      
      Gtt->give_code_numbers (i,rcn.a);
      if((ntm*ncomp) == 1){
	ccn[0] = 1;
      }
      if((ntm*ncomp) == 2){
	ccn[0] = 1;
	ccn[1] = 2;
      }
      if((ntm*ncomp) == 3){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
      }
      if((ntm*ncomp) == 4){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
 	ccn[3] = 4;
      }
      if((ntm*ncomp) == 6){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
 	ccn[3] = 4;
	ccn[4] = 5;
 	ccn[5] = 6;
      }
      if((ntm*ncomp) == 9){
	ccn[0] = 1;
	ccn[1] = 2;
	ccn[2] = 3;
 	ccn[3] = 4;
	ccn[4] = 5;
 	ccn[5] = 6;
 	ccn[6] = 7;
	ccn[7] = 8;
 	ccn[8] = 9;
      }
      
      //  localization of l_t matrix
      mat_localize (ltm,lkmt,rcn.a,ccn.a);
    }
  }
}



/**
   function assembles conductivity %matrix of PUC
   
   @param lcid - load case id
*/
void assemble_conductivity_matrix (matrix &km)
{
  long i,ndofe;
  ivector cn;
  matrix lm;
  
  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    if (Gtt->leso[i]==1){
      //  number of DOFs on element
      ndofe = Gtt->give_ndofe (i);
      
      reallocm (RSTCKMAT(ndofe,ndofe,lm));
      //  conductivity matrix of one element
      conductmat (i,0,lm);

      check_math_errel(i);            

      reallocv(RSTCKIVEC(ndofe, cn));
      Gtt->give_code_numbers (i,cn.a);
      
      mat_localize (km,lm,cn.a,cn.a);
    }
  }
}

/**
   function assembles average conductivity (D) %matrix of PUC
   
   @param lcid - load case id
*/
void assemble_average_d_matrix (matrix &km, double &area)
{
  long i,ii,jj,ntm,ncomp;
  double elemarea,invarea;
  matrix lm;
  
  area = 0.0;
  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    elemarea = 0.0;
    if (Gtt->leso[i]==1){

      ntm = Tp->ntm;
      ncomp = Tt->give_ncomp(i);

      reallocm (RSTCKMAT(ncomp*ntm,ncomp*ntm,lm));

      //  conductivity D matrix of one element
      averdmat (i,elemarea,lm);
      
      check_math_errel(i);            

      for (ii=0;ii<ntm*ncomp;ii++){
	for (jj=0;jj<ntm*ncomp;jj++){
	  km[ii][jj]+=lm[ii][jj]*elemarea;
	}
      }
      area += elemarea;
    }
  }

  invarea = 1.0/area;
  cmulm(invarea,km);
}

/**
   function assembles average capacity (C) %matrix of PUC
   
   @param lcid - load case id
*/
void assemble_average_c_matrix (matrix &cm)
{
  long i,ii,jj,ntm,ncomp;
  double elemarea,area;
  matrix lm;
  
  area = 0.0;
  //  loop over elements
  for (i=0;i<Tt->ne;i++){
    elemarea = 0.0;
    if (Gtt->leso[i]==1){
      
      ntm = Tp->ntm;
      ncomp = Tt->give_ncomp(i);
      
      reallocm (RSTCKMAT(ntm,ntm,lm));
      
      //  capacity C matrix of one element
      avercmat (i,elemarea,lm);
      
      check_math_errel(i);            
      
      //fprintf(Outt,"\nelemarea[%ld] = %lf\n",i,elemarea);
      
      
      for (ii=0;ii<ntm;ii++){
	for (jj=0;jj<ntm;jj++){
	  //  fprintf(Outt,"Tb->lc[%ld].masterval = %lf\n",jj,Tb->lc[jj].masterval);
	  //  fprintf(Outt,"lm[%ld][%ld] = %lf\n",ii,jj,lm[ii][jj]);
	  
	  cm[ii][jj]+=lm[ii][jj]*elemarea/Tb->lc[jj].masterval;
	  //cm[ii][jj]+=lm[ii][jj]*elemarea;//here, it should be disscussed
	}
      }
      area += elemarea;
    }
  }
  
  //for (ii=0;ii<ntm;ii++)
  //  for (jj=0;jj<ntm;jj++)
  //    fprintf(Outt,"cm[%ld][%ld] = %e\n",ii,jj,cm[ii][jj]);
  
  area = 1.0/area;
  cmulm(area,cm);
}

/**
   function computes integral of a variable over the whole domain
   the variable is stored on nodes
   
   @param lcid - load case id
   
   14. 3. 2013
*/
double total_integral (long lcid)
{
  long i, j, nne;
  double totint;
  ivector cn, enod;
  vector nodval;
  
  totint=0.0;
  
  //  loop over the elements
  for (i=0;i<Tt->ne;i++){
    
    //  the number of nodes on element
    nne = Tt->give_nne (i);
    reallocv (RSTCKVEC(nne,nodval));
    reallocv (RSTCKIVEC(nne,enod));
    Tt->give_elemnodes(i, enod);
    
    for(j=0; j<nne; j++)
      nodval[j] = nodalval(enod[j], lcid);

    totint+=elem_total_integral (i,nodval);
    
    check_math_errel(i);            
  }
  
  return totint;
}

/**
   function computes integral of a variable over the whole domain
   the variable is stored in integration points in array other
   
   @param varid - id of variable required, it is an index in the array other
   
   3. 10. 2013, JK
*/
double total_integral_ip (long varid)
{
  long i;
  double totint;
  
  //  the total integral
  totint=0.0;
  
  //  loop over the elements
  for (i=0;i<Tt->ne;i++){
    totint+=elem_total_integral_ip (i,varid);
  }
  
  return totint;
}

/**
   function determines time increment for each subdomain
   
   JK, 27. 5. 2014
*/
void dt_subdom ()
{
  long i,j;
  long ns,nes,eid;
  
  //  the number of subdomain
  ns = Gtt->stop->ns;
  
  //  loop over the number of subdomains
  for (i=0;i<ns;i++){
    //  the number of elements on the i-th subdomain
    nes = Gtt->stop->ned[i];
    
    //  loop over the number of elements on the i-th subdomain
    for (j=0;j<nes;j++){
      //  element id
      eid = Gtt->stop->domel[i][j];

      //  je nutne nastavit varid
      //  je nutne definovat promennnou
      //elem_total_integral_ip (eid,varid);
      
    }//  end of the loop over the number of elements on the i-th subdomain
  }//  end of the loop over the number of subdomains
}

/**
   function sets actual values of arrays lnso and leso
   
   nodes and elements are switched on or off with respect
   to subcycling algorithm
   
   @param lsso - list of subdomains switched on/off

   JK, 27. 5. 2014
*/
void lnso_leso_setting (long *lsso)
{
  long i,j;
  long ns,nes,nne,eid;
  ivector nodes;
  
  //  the number of subdomain
  ns = Gtt->stop->ns;
  
  // **********************
  //  setting of elements
  // **********************
  //  loop over the number of subdomains
  for (i=0;i<ns;i++){
    //  the number of elements on the i-th subdomain
    nes = Gtt->stop->ned[i];
    
    if (lsso[i]==0){
      //  loop over the number of elements on the i-th subdomain
      for (j=0;j<nes;j++){
	//  element id
	eid = Gtt->stop->domel[i][j];
	
	Gtt->leso[eid]=0;
      }//  end of the loop over the number of elements on the i-th subdomain
    }//  end of the statement if (lsso[i]==0){
    if (lsso[i]==1){
      //  loop over the number of elements on the i-th subdomain
      for (j=0;j<nes;j++){
	//  element id
	eid = Gtt->stop->domel[i][j];
	
	Gtt->leso[eid]=1;
      }//  end of the loop over the number of elements on the i-th subdomain
    }//  end of the statement if (lsso[i]==1){
  }//  end of the loop over the number of subdomains
  
  // *******************
  //  setting of nodes
  // *******************
  //  loop over the number of all nodes
  for (i=0;i<Tt->nn;i++){
    Gtt->lnso[i]=1;
  }//  end of the loop over the number of all nodes
  
  //  loop over the number of elements
  for (i=0;i<Tt->ne;i++){
    
    if (Gtt->leso[i]==0){
      
      //  the number of nodes on element
      nne = Tt->give_nne (i);
      reallocv (RSTCKIVEC(nne,nodes));
      //  nodes on element
      Tt->give_elemnodes (i,nodes);
      
      //  loop over the number of nodes on element
      for (j=0;j<nne;j++){
	Gtt->lnso[nodes[j]]=0;
      }
    }//  end of the statement if (Gtt->leso[i]=0){
  }//  end of the loop over the number of elements
  
}

/**
   function computes fluxes through prescribed domain surfaces
   
   JK, 5. 3. 2018
*/
void surface_fluxes (FILE *out)
{
  long i,j,nef,eid;
  
  //  array is clean for new contributions
  nullv (Tb->fluxes,Tb->nbf);
  
  for (j=0;j<Tp->ntm;j++){
    
    //  number of elements with surface where the integration will be performed
    nef = Tb->bf[j].neb;
    
    for (i=0;i<nef;i++){
      //  element id
      eid=Tb->bf[j].elemload[i].eid;
      //  surface flux
      elem_surface_flux (eid,j,i,Tb->fluxes);
    }
  }
  
  fprintf (out,"%e  %e",Tp->time/86400,Tp->timecont.actualbacktimeincr());

  for (i=0;i<Tb->nbf;i++){
    fprintf (stdout,"Time = %lf, flux No.%ld =  %e",Tp->time,i+1,Tb->fluxes[i]);
    fprintf (out,"  %e  %e",Tb->fluxes[i],Tp->timecont.actualbacktimeincr()*Tb->fluxes[i]);
  }

  fprintf (stdout,"\n");
  fprintf (out,"\n");
  fflush (out);
}

/**
   function returns fluxes computed through prescribed domain surfaces
   
   TKr, 26/2/2021
*/
double surface_fluxes (long /*lcid*/, long nbf)
{
  long i,j,nef,eid;
  
  //  array is clean for new contributions
  nullv (Tb->fluxes,Tb->nbf);
  
  for (j=0;j<Tp->ntm;j++){
    
    //  number of elements with surface where the integration will be performed
    nef = Tb->bf[j].neb;
    
    for (i=0;i<nef;i++){
      //  element id
      eid=Tb->bf[j].elemload[i].eid;
      //  surface flux
      elem_surface_flux (eid,j,i,Tb->fluxes);
    }
  }
  
  return(Tb->fluxes[nbf]);
}
